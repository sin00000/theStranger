<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Stranger - Interactive French Typography</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', 'Times New Roman', serif;
            overflow: hidden;
            background: #1a1a1a;
        }

        #canvas {
            display: block;
            cursor: pointer;
        }

        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #888;
            font-size: 14px;
            pointer-events: none;
        }

        @media (max-width: 600px) {
            .info {
                font-size: 10px;
                top: 10px;
                left: 10px;
            }
        }

        .completion-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: white;
            font-size: 24px;
            text-align: center;
            z-index: 10;
        }

        .completion-overlay.show {
            display: flex;
        }

        .completion-message {
            margin-bottom: 20px;
            font-size: 16px;
            color: #888;
        }

        #completedSentence {
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            font-weight: 300;
            font-size: 36px;
            padding: 0 20px;
            max-width: 90vw;
            word-wrap: break-word;
        }

        @media (max-width: 600px) {
            #completedSentence {
                font-size: 20px;
            }
            .completion-message {
                font-size: 12px;
            }
        }

        @media (min-width: 601px) and (max-width: 1024px) {
            #completedSentence {
                font-size: 28px;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="info">
        DRAG to reposition • CLICK to place in sentence
    </div>
    <div class="completion-overlay" id="completionOverlay">
        <div class="completion-message">Sentence completed</div>
        <div id="completedSentence" style="cursor: pointer;"></div>
    </div>

    <script>
        // ========================================
        // CONFIGURATION
        // ========================================
        const SENTENCE = "Aujourd'hui, maman est morte. Ou peut-être hier.";
        const FLOATING_AREA_RATIO = 0.8; // 80% for floating, 20% for sentence area

        const LETTER_CONFIG_BASE = {
            floating: {
                minSize: 60,
                maxSize: 80,
                weight: 700,
                style: 'normal'
            },
            placed: {
                size: 28,
                weight: 300,
                style: 'normal'
            },
            transition: {
                duration: 30 // frames
            }
        };

        // Responsive letter config with getters
        const LETTER_CONFIG = {
            get floating() {
                const scale = getResponsiveScale();
                return {
                    minSize: LETTER_CONFIG_BASE.floating.minSize * scale.floating,
                    maxSize: LETTER_CONFIG_BASE.floating.maxSize * scale.floating,
                    weight: LETTER_CONFIG_BASE.floating.weight,
                    style: LETTER_CONFIG_BASE.floating.style
                };
            },
            get placed() {
                const scale = getResponsiveScale();
                return {
                    size: LETTER_CONFIG_BASE.placed.size * scale.placed,
                    weight: LETTER_CONFIG_BASE.placed.weight,
                    style: LETTER_CONFIG_BASE.placed.style
                };
            },
            get transition() {
                return LETTER_CONFIG_BASE.transition;
            }
        };

        // ========================================
        // GLOBAL STATE
        // ========================================
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width, height;
        let floatingAreaHeight, sentenceAreaTop;

        // Data structures
        let letterMapping = {}; // letter -> array of target positions
        let letterStates = []; // array of letter position objects
        let floatingLetters = []; // array of floating letter particles
        let allLettersPlaced = false;
        let germanMaleVoice = null; // German male voice for final sentence
        let availableVoices = []; // All available voices

        // Drag state
        let draggedParticle = null;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let wasDragging = false; // Track if we just finished dragging

        // ========================================
        // RESPONSIVE UTILITIES
        // ========================================
        function getResponsiveScale() {
            const screenWidth = window.innerWidth;

            // Mobile: < 600px
            if (screenWidth < 600) {
                return {
                    floating: 0.4,  // 40% of base size
                    placed: 0.5,    // 50% of base size
                    letterWidth: 0.5,
                    letterSpacing: 0.5
                };
            }
            // Tablet: 600-1024px
            else if (screenWidth < 1024) {
                return {
                    floating: 0.65,
                    placed: 0.75,
                    letterWidth: 0.75,
                    letterSpacing: 0.75
                };
            }
            // Desktop: >= 1024px
            else {
                return {
                    floating: 1.0,
                    placed: 1.0,
                    letterWidth: 1.0,
                    letterSpacing: 1.0
                };
            }
        }

        function getResponsiveLetterDimensions() {
            const scale = getResponsiveScale();
            const baseLetterWidth = 18;
            const baseLetterSpacing = 2;

            return {
                letterWidth: baseLetterWidth * scale.letterWidth,
                letterSpacing: baseLetterSpacing * scale.letterSpacing
            };
        }

        // ========================================
        // INITIALIZATION
        // ========================================
        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Add mouse event listeners for drag and click
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('click', handleClick);

            // Load voices
            loadVoices();

            // Step 1: Decompose sentence and create mappings
            decomposeSentence();

            // Step 2: Create floating letter particles
            createFloatingLetters();

            // Step 3: Start animation loop
            animate();

            console.log('=== LETTER MAPPING ===');
            console.log(letterMapping);
            console.log('\n=== LETTER STATES ===');
            console.log(letterStates);
        }

        function resizeCanvas() {
            const oldWidth = width;
            const oldHeight = height;

            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            floatingAreaHeight = height * FLOATING_AREA_RATIO;
            sentenceAreaTop = floatingAreaHeight;

            // If this is a resize (not initial load), update positions
            if (oldWidth && oldHeight) {
                updatePositionsAfterResize(oldWidth, oldHeight);
            }
        }

        function updatePositionsAfterResize(oldWidth, oldHeight) {
            // 1. Constrain floating letters to new bounds
            floatingLetters.forEach(particle => {
                if (particle.isFloating) {
                    // Scale position proportionally
                    particle.x = (particle.x / oldWidth) * width;
                    particle.y = (particle.y / (oldHeight * FLOATING_AREA_RATIO)) * floatingAreaHeight;

                    // Ensure within bounds
                    particle.x = Math.max(0, Math.min(width, particle.x));
                    particle.y = Math.max(0, Math.min(floatingAreaHeight, particle.y));
                }
            });

            // 2. Recalculate positions for placed/transitioning letters
            floatingLetters.forEach(particle => {
                if (!particle.isFloating || particle.isTransitioning) {
                    // Find which letter state this particle is associated with
                    const targetIndex = findTargetIndexForParticle(particle);

                    if (targetIndex !== -1) {
                        const { letterWidth, letterSpacing } = getResponsiveLetterDimensions();
                        const totalWidth = letterStates.length * (letterWidth + letterSpacing);
                        const startX = (width - totalWidth) / 2;
                        const targetX = startX + (targetIndex * (letterWidth + letterSpacing)) + letterWidth / 2;
                        const baseY = sentenceAreaTop + (height - sentenceAreaTop) / 2;

                        // Update target position
                        particle.targetX = targetX;
                        particle.targetY = baseY;

                        // If already placed (not transitioning), update current position immediately
                        if (!particle.isTransitioning) {
                            particle.x = targetX;
                            particle.y = baseY;
                        }

                        // Update target size based on new responsive scale
                        const placedConfig = LETTER_CONFIG.placed;
                        particle.targetSize = placedConfig.size;
                        if (!particle.isTransitioning) {
                            particle.size = placedConfig.size;
                        }
                    }
                }
            });
        }

        function findTargetIndexForParticle(particle) {
            // Find which position in letterStates this particle occupies
            for (let i = 0; i < letterStates.length; i++) {
                if (letterStates[i].particle === particle) {
                    return i;
                }
            }
            return -1;
        }

        // ========================================
        // FRENCH LETTER DECOMPOSITION & MAPPING
        // ========================================
        function isSpecialCharacter(char) {
            // Check if character is punctuation or special character
            // Include: spaces, hyphens, apostrophes, commas, periods, etc.
            const specialChars = /[^a-zA-ZÀ-ÿ]/; // Everything except letters (including accented)
            return specialChars.test(char);
        }

        function decomposeSentence() {
            letterMapping = {};
            letterStates = [];

            // Decompose into individual characters
            for (let i = 0; i < SENTENCE.length; i++) {
                const char = SENTENCE[i];

                const isSpecial = isSpecialCharacter(char);

                const letterState = {
                    char: char,
                    index: i,
                    filled: false,
                    particle: null,
                    isSpace: char === ' ',
                    isPunctuation: isSpecial && char !== ' ' // Any special char that's not a space
                };

                letterStates.push(letterState);

                // Skip spaces and all special characters from mapping (they're auto-complete)
                if (isSpecial) {
                    letterState.filled = true;
                    continue;
                }

                // Only add alphabetic letters to the mapping
                if (!letterMapping[char]) {
                    letterMapping[char] = [];
                }

                letterMapping[char].push({
                    index: i,
                    char: char,
                    filled: false,
                    stateRef: letterState
                });
            }

            // Log statistics
            console.log('\n=== LETTER STATISTICS ===');
            console.log('Total characters in sentence:', SENTENCE.length);
            console.log('Alphabetic letters (floating):', Object.keys(letterMapping).length, 'unique');
            console.log('Total letter instances:', Object.values(letterMapping).reduce((sum, arr) => sum + arr.length, 0));
            console.log('Special characters (auto-filled):', letterStates.filter(s => s.isSpace || s.isPunctuation).length);

            console.log('\n=== DUPLICATE LETTERS ===');
            Object.entries(letterMapping).forEach(([letter, positions]) => {
                if (positions.length > 1) {
                    console.log(`"${letter}": ${positions.length} occurrences at positions:`,
                        positions.map(p => p.index));
                }
            });

            console.log('\n=== SPECIAL CHARACTERS (NOT FLOATING) ===');
            const specialChars = letterStates.filter(s => s.isSpace || s.isPunctuation);
            console.log('Characters excluded from floating:', specialChars.map(s => s.char).join(''));
        }

        // ========================================
        // FLOATING LETTER PARTICLES
        // ========================================
        function createFloatingLetters() {
            floatingLetters = [];
            const uniqueLetters = Object.keys(letterMapping);

            uniqueLetters.forEach(letter => {
                const count = letterMapping[letter].length;

                // Create one particle for each occurrence
                for (let i = 0; i < count; i++) {
                    const size = LETTER_CONFIG.floating.minSize +
                                Math.random() * (LETTER_CONFIG.floating.maxSize - LETTER_CONFIG.floating.minSize);

                    // Create unique physics for each letter
                    // Determine if this letter is "light" or "heavy"
                    const physicsType = Math.random();
                    let speedMultiplier, vxRange, vyRange;

                    if (physicsType < 0.3) {
                        // Light and floaty (30% of letters)
                        speedMultiplier = 0.3 + Math.random() * 0.4; // 0.3 to 0.7
                        vxRange = speedMultiplier * (0.5 + Math.random() * 1.5); // Gentle horizontal drift
                        vyRange = speedMultiplier * (0.5 + Math.random() * 1.5); // Gentle vertical drift
                    } else if (physicsType < 0.6) {
                        // Medium speed (30% of letters)
                        speedMultiplier = 1.0 + Math.random() * 1.0; // 1.0 to 2.0
                        vxRange = speedMultiplier * (Math.random() * 2.0);
                        vyRange = speedMultiplier * (Math.random() * 2.0);
                    } else {
                        // Heavy and fast (40% of letters)
                        speedMultiplier = 2.0 + Math.random() * 2.0; // 2.0 to 4.0
                        vxRange = speedMultiplier * (0.5 + Math.random() * 1.5);
                        vyRange = speedMultiplier * (0.5 + Math.random() * 1.5);
                    }

                    // Independent horizontal and vertical velocities
                    // Randomize direction independently
                    const vx = (Math.random() - 0.5) * 2 * vxRange;
                    const vy = (Math.random() - 0.5) * 2 * vyRange;

                    const particle = {
                        letter: letter,
                        x: Math.random() * width,
                        y: Math.random() * floatingAreaHeight,
                        vx: vx,
                        vy: vy,
                        baseSpeed: Math.sqrt(vx * vx + vy * vy), // Store original speed magnitude
                        speedMultiplier: speedMultiplier, // Store for visual feedback
                        size: size,
                        weight: LETTER_CONFIG.floating.weight,
                        rotation: (Math.random() - 0.5) * 0.3,
                        rotationSpeed: (Math.random() - 0.5) * 0.02 * speedMultiplier, // Faster letters rotate more
                        isFloating: true,
                        isTransitioning: false,
                        isDragging: false,
                        transitionFrame: 0,
                        targetX: 0,
                        targetY: 0,
                        targetSize: LETTER_CONFIG.placed.size,
                        targetWeight: LETTER_CONFIG.placed.weight,
                        targetRotation: 0,
                        startX: 0,
                        startY: 0,
                        startSize: size,
                        startWeight: LETTER_CONFIG.floating.weight,
                        startRotation: 0,
                        // Color properties
                        color: null, // Will be assigned when dragged
                        originalColor: null, // Store the original assigned color
                        colorFadeStartTime: null, // When to start fading color
                        fontFamilyTransition: 0, // 0 = Georgia, 1 = Helvetica
                        // Interaction tracking
                        wasDragged: false, // Track if letter was dragged
                        wasClicked: false, // Track if letter was clicked and placed
                        dropTime: null, // Time when letter was dropped (for drag fade)
                        lastVoiceTime: null, // Track when voice was last played (for cooldown)
                        // Drag physics
                        dragTargetX: 0, // Mouse position for spring physics
                        dragTargetY: 0,
                        dragVx: 0, // Velocity tracking during drag
                        dragVy: 0,
                        lastDragX: 0, // Previous mouse position for velocity calculation
                        lastDragY: 0
                    };

                    floatingLetters.push(particle);
                }
            });

            console.log(`Created ${floatingLetters.length} floating letter particles`);
        }

        // ========================================
        // COLLISION DETECTION & PHYSICS
        // ========================================
        function handleCollisions() {
            // Only check collisions between floating particles
            const floatingParticles = floatingLetters.filter(p => p.isFloating && !p.isDragging);

            // Optimization: Use spatial grid to reduce collision checks
            // Grid cell size based on largest letter size
            const cellSize = LETTER_CONFIG_BASE.floating.maxSize * 2;
            const grid = {};

            // Assign particles to grid cells
            floatingParticles.forEach(p => {
                const cellX = Math.floor(p.x / cellSize);
                const cellY = Math.floor(p.y / cellSize);
                const key = `${cellX},${cellY}`;

                if (!grid[key]) grid[key] = [];
                grid[key].push(p);
            });

            // Check collisions only within same and neighboring cells
            Object.values(grid).forEach(cell => {
                // Check all pairs within this cell
                for (let i = 0; i < cell.length; i++) {
                    for (let j = i + 1; j < cell.length; j++) {
                        checkAndResolveCollision(cell[i], cell[j]);
                    }
                }
            });
        }

        function checkAndResolveCollision(p1, p2) {
            // Calculate distance between centers
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // Calculate collision radius (approximate based on font size)
            // Letters are roughly circular, radius is about half the font size
            const radius1 = p1.size / 2.5; // Slightly smaller hitbox for more natural feel
            const radius2 = p2.size / 2.5;
            const minDistance = radius1 + radius2;

            // Check for collision
            if (distance < minDistance && distance > 0.1) {
                // Collision detected! Apply elastic collision physics

                // Normalize the collision vector
                const nx = dx / distance;
                const ny = dy / distance;

                // Relative velocity
                const dvx = p2.vx - p1.vx;
                const dvy = p2.vy - p1.vy;

                // Relative velocity in collision normal direction
                const dvn = dvx * nx + dvy * ny;

                // Don't process if particles are moving apart
                if (dvn >= 0) return;

                // Coefficient of restitution (bounciness): 0.8 for slightly damped collision
                const restitution = 0.85;

                // Calculate impulse magnitude for equal mass particles
                // impulse = -(1 + restitution) * relativeVelocityAlongNormal / 2
                const impulseMagnitude = -(1 + restitution) * dvn / 2;

                // Apply impulse to both particles
                const impulseX = impulseMagnitude * nx;
                const impulseY = impulseMagnitude * ny;

                p1.vx -= impulseX;
                p1.vy -= impulseY;
                p2.vx += impulseX;
                p2.vy += impulseY;

                // Separate overlapping particles to prevent sticking
                const overlap = minDistance - distance;
                const separationRatio = 0.6; // Move particles 60% of overlap distance
                const separationX = (overlap * separationRatio / 2) * nx;
                const separationY = (overlap * separationRatio / 2) * ny;

                p1.x -= separationX;
                p1.y -= separationY;
                p2.x += separationX;
                p2.y += separationY;

                // Add rotation based on tangential impact
                // Tangent vector perpendicular to normal
                const tx = -ny;
                const ty = nx;

                // Tangential velocity component
                const dvt = dvx * tx + dvy * ty;

                // Apply rotational impulse proportional to tangential velocity
                const rotationImpulse = dvt * 0.005;
                p1.rotationSpeed += rotationImpulse;
                p2.rotationSpeed -= rotationImpulse;

                // Apply slight damping to rotation
                p1.rotationSpeed *= 0.98;
                p2.rotationSpeed *= 0.98;

                // Clamp rotation speed
                const maxRotationSpeed = 0.08;
                p1.rotationSpeed = Math.max(-maxRotationSpeed, Math.min(maxRotationSpeed, p1.rotationSpeed));
                p2.rotationSpeed = Math.max(-maxRotationSpeed, Math.min(maxRotationSpeed, p2.rotationSpeed));
            }
        }

        // ========================================
        // ANIMATION LOOP
        // ========================================
        function animate() {
            ctx.clearRect(0, 0, width, height);

            // Draw background division
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, width, floatingAreaHeight);

            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(0, sentenceAreaTop, width, height - sentenceAreaTop);

            // Update and draw floating letters
            floatingLetters.forEach(particle => {
                if (particle.isDragging) {
                    updateDraggingParticle(particle);
                } else if (particle.isFloating) {
                    updateFloatingParticle(particle);
                } else if (particle.isTransitioning) {
                    updateTransitioningParticle(particle);
                }
                drawLetter(particle);
            });

            // Handle collisions between floating letters
            handleCollisions();

            // Draw sentence area
            drawSentenceArea();

            requestAnimationFrame(animate);
        }

        function updateFloatingParticle(particle) {
            // Update position with unique velocity
            particle.x += particle.vx;
            particle.y += particle.vy;

            // Update rotation continuously based on speed
            particle.rotation += particle.rotationSpeed;

            // Bounce off walls with damping and variation
            const wallDamping = 0.92; // Slight energy loss on wall bounce

            if (particle.x < 0 || particle.x > width) {
                particle.vx *= -wallDamping;
                particle.x = Math.max(0, Math.min(width, particle.x));

                // Add tiny random variation on bounce (chaos effect)
                const variation = 0.98 + Math.random() * 0.04; // 98% to 102%
                particle.vx *= variation;
            }
            if (particle.y < 0 || particle.y > floatingAreaHeight) {
                particle.vy *= -wallDamping;
                particle.y = Math.max(0, Math.min(floatingAreaHeight, particle.y));

                // Add tiny random variation on bounce
                const variation = 0.98 + Math.random() * 0.04;
                particle.vy *= variation;
            }

            // Apply very slight air resistance for smoother motion
            particle.vx *= 0.998;
            particle.vy *= 0.998;

            // Handle time-based transitions for dragged letters
            if (particle.wasDragged && particle.dropTime) {
                const now = Date.now();
                const elapsed = (now - particle.dropTime) / 1000; // seconds

                const HOLD_DURATION = 10; // Hold color/font for 10 seconds
                const FADE_DURATION = 3; // Fade over 3 seconds

                if (elapsed > HOLD_DURATION) {
                    const fadeProgress = Math.min((elapsed - HOLD_DURATION) / FADE_DURATION, 1.0);

                    // Fade font back to Georgia
                    particle.fontFamilyTransition = lerp(1.0, 0, fadeProgress);

                    // Fade color back to white
                    if (particle.originalColor && fadeProgress < 1.0) {
                        const color = interpolateColorToWhite(particle.originalColor, fadeProgress);
                        particle.color = color;
                    } else if (fadeProgress >= 1.0) {
                        particle.color = null; // Fully white (will use default)
                        particle.wasDragged = false;
                        particle.dropTime = null;
                        particle.originalColor = null;
                        particle.fontFamilyTransition = 0;
                    }
                }
            }
        }

        function updateDraggingParticle(particle) {
            // Transition to Helvetica while dragging
            particle.fontFamilyTransition = Math.min(particle.fontFamilyTransition + 0.05, 1.0);

            // Slight size increase while dragging
            const dragSize = particle.startSize * 1.2;
            particle.size = lerp(particle.size, dragSize, 0.2);

            // Spring physics: letter follows mouse with inertia
            const springStiffness = 0.25; // How quickly it follows (0-1, lower = more lag)
            const damping = 0.85; // Velocity damping (0-1, lower = more friction)

            // Calculate spring force toward target (mouse position)
            const dx = particle.dragTargetX - particle.x;
            const dy = particle.dragTargetY - particle.y;

            // Apply spring force to velocity
            particle.dragVx += dx * springStiffness;
            particle.dragVy += dy * springStiffness;

            // Apply damping to prevent oscillation
            particle.dragVx *= damping;
            particle.dragVy *= damping;

            // Update position based on velocity
            particle.x += particle.dragVx;
            particle.y += particle.dragVy;
        }

        function updateTransitioningParticle(particle) {
            particle.transitionFrame++;
            const progress = particle.transitionFrame / LETTER_CONFIG.transition.duration;
            const eased = easeInOutCubic(progress);

            if (progress >= 1) {
                particle.x = particle.targetX;
                particle.y = particle.targetY;
                particle.size = particle.targetSize;
                particle.weight = particle.targetWeight;
                particle.rotation = particle.targetRotation;
                particle.fontFamilyTransition = 1.0; // Fully Helvetica
                particle.isTransitioning = false;

                // Start color fade timer for clicked letters
                if (particle.wasClicked) {
                    particle.colorFadeStartTime = Date.now();
                }
            } else {
                particle.x = lerp(particle.startX, particle.targetX, eased);
                particle.y = lerp(particle.startY, particle.targetY, eased);
                particle.size = lerp(particle.startSize, particle.targetSize, eased);
                particle.weight = lerp(particle.startWeight, particle.targetWeight, eased);
                particle.rotation = lerp(particle.startRotation, particle.targetRotation, eased);
                particle.fontFamilyTransition = lerp(0, 1, eased); // Transition font
            }

            // Handle time-based color fade for clicked/placed letters
            if (particle.wasClicked && particle.colorFadeStartTime) {
                const now = Date.now();
                const elapsed = (now - particle.colorFadeStartTime) / 1000; // seconds

                const FADE_START = 0; // Start fading immediately
                const FADE_DURATION = 15 + Math.random() * 5; // 15-20 seconds

                if (elapsed > FADE_START) {
                    const fadeProgress = Math.min((elapsed - FADE_START) / FADE_DURATION, 1.0);

                    // Fade color to white, keep Helvetica
                    if (particle.originalColor && fadeProgress < 1.0) {
                        const color = interpolateColorToWhite(particle.originalColor, fadeProgress);
                        particle.color = color;
                    } else if (fadeProgress >= 1.0) {
                        particle.color = 'rgba(255, 255, 255, 1.0)'; // Pure white
                        // Keep Helvetica (fontFamilyTransition stays at 1.0)
                    }
                }
            }
        }

        function drawLetter(particle) {
            ctx.save();
            ctx.translate(particle.x, particle.y);
            ctx.rotate(particle.rotation);

            // Interpolate between Georgia and Helvetica based on fontFamilyTransition
            // For canvas, we can't truly interpolate fonts, so we switch at 0.5 threshold
            const fontFamily = particle.fontFamilyTransition < 0.5 ?
                'Georgia, serif' :
                "'Helvetica Neue', Helvetica, Arial, sans-serif";
            ctx.font = `${particle.weight} ${particle.size}px ${fontFamily}`;

            // Determine color
            let fillColor;

            if (particle.color) {
                // If color is assigned (dragged), use it
                fillColor = particle.color;
            } else if (particle.isFloating && !particle.isDragging) {
                // Floating letters: white with opacity based on speed
                const opacity = particle.speedMultiplier ?
                    Math.min(0.6 + particle.speedMultiplier * 0.15, 1.0) : 1.0;
                fillColor = `rgba(255, 255, 255, ${opacity})`;

                // Vary shadow based on speed
                const shadowIntensity = particle.speedMultiplier ?
                    5 + particle.speedMultiplier * 3 : 10;
                ctx.shadowBlur = shadowIntensity;
                ctx.shadowColor = `rgba(255, 255, 255, ${opacity * 0.4})`;
            } else if (particle.isFloating || particle.isDragging) {
                // Dragging but no color yet
                fillColor = '#ffffff';
            } else {
                // Placed letters without drag (click interaction)
                fillColor = '#00ff88';
            }

            ctx.fillStyle = fillColor;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            ctx.fillText(particle.letter, 0, 0);
            ctx.restore();
        }

        // ========================================
        // SENTENCE AREA RENDERING
        // ========================================
        function drawSentenceArea() {
            const baseY = sentenceAreaTop + (height - sentenceAreaTop) / 2;
            const { letterWidth, letterSpacing } = getResponsiveLetterDimensions();

            // Calculate total width
            const totalWidth = letterStates.length * (letterWidth + letterSpacing);
            let currentX = (width - totalWidth) / 2;

            letterStates.forEach((letterState, idx) => {
                const charX = currentX + letterWidth / 2;

                // Draw placeholder box for letters (not spaces/punctuation)
                if (!letterState.isSpace && !letterState.isPunctuation) {
                    ctx.strokeStyle = letterState.filled ? '#00ff88' : '#444';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(currentX, baseY - 20, letterWidth, 40);
                }

                // Draw placed letters or punctuation/spaces
                if (letterState.filled && (letterState.isSpace || letterState.isPunctuation)) {
                    const placedConfig = LETTER_CONFIG.placed;
                    ctx.font = `${placedConfig.weight} ${placedConfig.size}px 'Helvetica Neue', Helvetica, Arial, sans-serif`;
                    ctx.fillStyle = '#888';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(letterState.char, charX, baseY);
                }

                currentX += letterWidth + letterSpacing;
            });

            // Check completion
            checkAllLettersPlaced();
        }

        function checkAllLettersPlaced() {
            const allComplete = letterStates.every(s => s.filled);
            if (allComplete && !allLettersPlaced) {
                allLettersPlaced = true;
                showCompletionOverlay();
            }
        }

        function showCompletionOverlay() {
            const overlay = document.getElementById('completionOverlay');
            const sentenceEl = document.getElementById('completedSentence');
            sentenceEl.textContent = SENTENCE;
            overlay.classList.add('show');

            sentenceEl.onclick = () => {
                speakFullSentence();
            };
        }

        // ========================================
        // MOUSE INTERACTION (DRAG & CLICK)
        // ========================================
        function generateRandomColor() {
            // Generate vibrant random colors
            const hue = Math.random() * 360;
            const saturation = 70 + Math.random() * 30; // 70-100%
            const lightness = 45 + Math.random() * 15; // 45-60%
            return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }

        function findParticleAt(mouseX, mouseY) {
            let nearestParticle = null;
            let nearestDist = Infinity;

            floatingLetters.forEach(particle => {
                if (!particle.isFloating || particle.isDragging) return;

                const dx = particle.x - mouseX;
                const dy = particle.y - mouseY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < nearestDist && dist < 50) { // Within 50px
                    nearestDist = dist;
                    nearestParticle = particle;
                }
            });

            return nearestParticle;
        }

        function handleMouseDown(event) {
            if (allLettersPlaced) return;

            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            dragStartX = mouseX;
            dragStartY = mouseY;
            wasDragging = false;

            // Find particle to drag
            const particle = findParticleAt(mouseX, mouseY);

            if (particle) {
                draggedParticle = particle;
                isDragging = false; // Will become true on mouse move
            }
        }

        function handleMouseMove(event) {
            if (!draggedParticle) return;

            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            // Check if mouse moved enough to be considered a drag
            const dx = mouseX - dragStartX;
            const dy = mouseY - dragStartY;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist > 5 && !isDragging) {
                isDragging = true;
                wasDragging = true;
                draggedParticle.isDragging = true;
                draggedParticle.isFloating = false;

                // Initialize drag physics
                draggedParticle.dragTargetX = mouseX;
                draggedParticle.dragTargetY = mouseY;
                draggedParticle.lastDragX = mouseX;
                draggedParticle.lastDragY = mouseY;
                draggedParticle.dragVx = 0;
                draggedParticle.dragVy = 0;

                // Assign random color when drag actually starts
                if (!draggedParticle.color) {
                    const randomColor = generateRandomColor();
                    draggedParticle.color = randomColor;
                    draggedParticle.originalColor = randomColor; // Store for fade
                }

                // Play voice when drag starts (with cooldown to avoid repetition)
                const now = Date.now();
                const VOICE_COOLDOWN = 2000; // 2 seconds cooldown
                if (!draggedParticle.lastVoiceTime || (now - draggedParticle.lastVoiceTime) > VOICE_COOLDOWN) {
                    speakLetter(draggedParticle.letter);
                    draggedParticle.lastVoiceTime = now;
                }
            }

            if (isDragging) {
                // Update drag target for spring physics
                draggedParticle.dragTargetX = mouseX;
                draggedParticle.dragTargetY = mouseY;
            }
        }

        function handleMouseUp(event) {
            if (!draggedParticle) return;

            if (isDragging) {
                // DRAG behavior: Drop at current position, keep floating with new color

                // Resume floating from current position
                draggedParticle.isDragging = false;
                draggedParticle.isFloating = true;

                // Inherit velocity from drag motion (with slight boost for natural feel)
                const velocityMultiplier = 1.2;
                draggedParticle.vx = draggedParticle.dragVx * velocityMultiplier;
                draggedParticle.vy = draggedParticle.dragVy * velocityMultiplier;

                // Clamp inherited velocity to prevent too fast movement
                const maxInheritedSpeed = 15;
                const currentSpeed = Math.sqrt(draggedParticle.vx ** 2 + draggedParticle.vy ** 2);
                if (currentSpeed > maxInheritedSpeed) {
                    const scale = maxInheritedSpeed / currentSpeed;
                    draggedParticle.vx *= scale;
                    draggedParticle.vy *= scale;
                }

                // Keep Helvetica for now (will fade back after 10 seconds)
                // fontFamilyTransition stays at 1.0

                // Reset size back to original
                draggedParticle.size = draggedParticle.startSize;

                // Mark as dragged and set drop time for fade timer
                draggedParticle.wasDragged = true;
                draggedParticle.dropTime = Date.now();

                // Color persists (already assigned)
            } else {
                // Short click (no drag) - do nothing here, handleClick will handle it
            }

            draggedParticle = null;
            isDragging = false;
        }

        function handleClick(event) {
            // CLICK behavior: Place letter in correct position with Helvetica transformation
            if (allLettersPlaced) return;

            // Don't trigger click if we just finished dragging
            if (wasDragging) {
                wasDragging = false;
                return;
            }

            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            const nearestParticle = findParticleAt(mouseX, mouseY);

            if (nearestParticle) {
                // Assign random color immediately on click
                if (!nearestParticle.color) {
                    const randomColor = generateRandomColor();
                    nearestParticle.color = randomColor;
                    nearestParticle.originalColor = randomColor; // Store for fade
                }

                // Mark as clicked for color fade behavior
                nearestParticle.wasClicked = true;

                // Place letter in correct sentence position
                // This will transform to Helvetica and lock in place
                placeLetter(nearestParticle);
            }
        }

        function placeLetter(particle) {
            const letter = particle.letter;
            const targets = letterMapping[letter];

            // Find first unfilled target
            const target = targets.find(t => !t.filled);
            if (!target) return;

            // Mark as filled
            target.filled = true;
            target.stateRef.filled = true;
            target.stateRef.particle = particle;

            // Calculate target position using responsive dimensions
            const { letterWidth, letterSpacing } = getResponsiveLetterDimensions();
            const totalWidth = letterStates.length * (letterWidth + letterSpacing);
            const startX = (width - totalWidth) / 2;

            const targetX = startX + (target.index * (letterWidth + letterSpacing)) + letterWidth / 2;
            const baseY = sentenceAreaTop + (height - sentenceAreaTop) / 2;

            // Start transition
            particle.isFloating = false;
            particle.isDragging = false; // Stop dragging
            particle.isTransitioning = true;
            particle.transitionFrame = 0;
            particle.startX = particle.x;
            particle.startY = particle.y;
            particle.startSize = particle.size;
            particle.startWeight = particle.weight;
            particle.startRotation = particle.rotation;
            particle.targetX = targetX;
            particle.targetY = baseY;
            particle.targetSize = LETTER_CONFIG.placed.size;
            particle.targetWeight = LETTER_CONFIG.placed.weight;
            particle.targetRotation = 0;

            // Ensure font transition completes if it was being dragged
            if (particle.fontFamilyTransition > 0 && particle.fontFamilyTransition < 1) {
                // Continue the font transition during placement
            }

            // Pronounce the letter
            speakLetter(letter);
        }

        // ========================================
        // WEB SPEECH API
        // ========================================
        function loadVoices() {
            if (!window.speechSynthesis) return;

            // Load voices (may take time on some browsers)
            const loadVoicesAsync = () => {
                availableVoices = speechSynthesis.getVoices();

                if (availableVoices.length > 0) {
                    // Find German male voice
                    germanMaleVoice = availableVoices.find(voice =>
                        voice.lang.startsWith('de') &&
                        (voice.name.toLowerCase().includes('male') ||
                         voice.name.toLowerCase().includes('mann') ||
                         voice.name.toLowerCase().includes('hans') ||
                         voice.name.toLowerCase().includes('markus'))
                    );

                    // Fallback to any German voice
                    if (!germanMaleVoice) {
                        germanMaleVoice = availableVoices.find(voice =>
                            voice.lang.startsWith('de')
                        );
                    }

                    console.log('\n=== AVAILABLE VOICES ===');
                    console.log('German voices:', availableVoices.filter(v => v.lang.startsWith('de')));
                    console.log('Selected German voice:', germanMaleVoice);
                }
            };

            loadVoicesAsync();

            // Voices may load asynchronously
            if (speechSynthesis.onvoiceschanged !== undefined) {
                speechSynthesis.onvoiceschanged = loadVoicesAsync;
            }
        }

        function speakLetter(letter) {
            if (!window.speechSynthesis) return;

            const utterance = new SpeechSynthesisUtterance(letter);
            utterance.lang = 'de-DE'; // German pronunciation for absurdist effect

            // Randomize pitch and rate for chaotic, varied sounds
            utterance.pitch = 0.6 + Math.random() * 1.0; // Range: 0.6 to 1.6
            utterance.rate = 0.7 + Math.random() * 0.8;  // Range: 0.7 to 1.5
            utterance.volume = 0.8 + Math.random() * 0.2; // Range: 0.8 to 1.0

            // Randomly select from available German voices for variety
            if (availableVoices.length > 0) {
                const germanVoices = availableVoices.filter(v => v.lang.startsWith('de'));
                if (germanVoices.length > 0) {
                    const randomVoice = germanVoices[Math.floor(Math.random() * germanVoices.length)];
                    utterance.voice = randomVoice;
                }
            }

            speechSynthesis.cancel(); // Cancel any ongoing speech
            speechSynthesis.speak(utterance);
        }

        function speakFullSentence() {
            if (!window.speechSynthesis) return;

            const utterance = new SpeechSynthesisUtterance(SENTENCE);
            utterance.lang = 'de-DE'; // German pronunciation of French text (absurdist)

            // Mechanical/robotic parameters
            utterance.pitch = 0.8;  // Lower pitch for mechanical tone
            utterance.rate = 0.9;   // Steady, deliberate pace
            utterance.volume = 1.0;

            // Use selected German male voice for cold, mechanical delivery
            if (germanMaleVoice) {
                utterance.voice = germanMaleVoice;
                console.log('Speaking with voice:', germanMaleVoice.name);
            }

            speechSynthesis.cancel();
            speechSynthesis.speak(utterance);
        }

        // ========================================
        // UTILITY FUNCTIONS
        // ========================================
        function lerp(start, end, t) {
            return start + (end - start) * t;
        }

        function easeInOutCubic(t) {
            return t < 0.5
                ? 4 * t * t * t
                : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        function interpolateColorToWhite(hslColor, progress) {
            // Parse HSL color string like "hsl(235, 85%, 52%)"
            const match = hslColor.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
            if (!match) return hslColor;

            const h = parseInt(match[1]);
            const s = parseInt(match[2]);
            const l = parseInt(match[3]);

            // Ease the progress for smoother transition
            const eased = easeInOutCubic(progress);

            // Interpolate to white: hsl(h, 0%, 100%)
            const newS = lerp(s, 0, eased);
            const newL = lerp(l, 100, eased);

            return `hsl(${h}, ${newS}%, ${newL}%)`;
        }

        // ========================================
        // START APPLICATION
        // ========================================
        init();
    </script>
</body>
</html>
