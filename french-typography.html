<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Stranger - Interactive French Typography</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', 'Times New Roman', serif;
            overflow: hidden;
            background: #1a1a1a;
        }

        #canvas {
            display: block;
            cursor: pointer;
        }

        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #888;
            font-size: 14px;
            pointer-events: none;
        }

        .completion-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: white;
            font-size: 24px;
            text-align: center;
            z-index: 10;
        }

        .completion-overlay.show {
            display: flex;
        }

        .completion-message {
            margin-bottom: 20px;
            font-size: 16px;
            color: #888;
        }

        #completedSentence {
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            font-weight: 300;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="info">
        Click on floating letters to construct the sentence
    </div>
    <div class="completion-overlay" id="completionOverlay">
        <div class="completion-message">Sentence completed</div>
        <div id="completedSentence" style="cursor: pointer; font-size: 36px;"></div>
    </div>

    <script>
        // ========================================
        // CONFIGURATION
        // ========================================
        const SENTENCE = "Aujourd'hui, maman est morte. Ou peut-Ãªtre hier.";
        const FLOATING_AREA_RATIO = 0.8; // 80% for floating, 20% for sentence area

        const LETTER_CONFIG = {
            floating: {
                minSize: 60,
                maxSize: 80,
                weight: 700,
                style: 'normal'
            },
            placed: {
                size: 28,
                weight: 300,
                style: 'normal'
            },
            transition: {
                duration: 30 // frames
            }
        };

        // ========================================
        // GLOBAL STATE
        // ========================================
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width, height;
        let floatingAreaHeight, sentenceAreaTop;

        // Data structures
        let letterMapping = {}; // letter -> array of target positions
        let letterStates = []; // array of letter position objects
        let floatingLetters = []; // array of floating letter particles
        let allLettersPlaced = false;
        let germanMaleVoice = null; // German male voice for final sentence
        let availableVoices = []; // All available voices

        // ========================================
        // INITIALIZATION
        // ========================================
        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            canvas.addEventListener('click', handleClick);

            // Load voices
            loadVoices();

            // Step 1: Decompose sentence and create mappings
            decomposeSentence();

            // Step 2: Create floating letter particles
            createFloatingLetters();

            // Step 3: Start animation loop
            animate();

            console.log('=== LETTER MAPPING ===');
            console.log(letterMapping);
            console.log('\n=== LETTER STATES ===');
            console.log(letterStates);
        }

        function resizeCanvas() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            floatingAreaHeight = height * FLOATING_AREA_RATIO;
            sentenceAreaTop = floatingAreaHeight;
        }

        // ========================================
        // FRENCH LETTER DECOMPOSITION & MAPPING
        // ========================================
        function decomposeSentence() {
            letterMapping = {};
            letterStates = [];

            // Decompose into individual characters
            for (let i = 0; i < SENTENCE.length; i++) {
                const char = SENTENCE[i];

                const letterState = {
                    char: char,
                    index: i,
                    filled: false,
                    particle: null,
                    isSpace: char === ' ',
                    isPunctuation: char === '.' || char === ',' || char === ';' || char === '!' || char === '?'
                };

                letterStates.push(letterState);

                // Skip spaces and punctuation from mapping (they're auto-complete)
                if (letterState.isSpace || letterState.isPunctuation) {
                    letterState.filled = true;
                    continue;
                }

                // Add to letter mapping
                if (!letterMapping[char]) {
                    letterMapping[char] = [];
                }

                letterMapping[char].push({
                    index: i,
                    char: char,
                    filled: false,
                    stateRef: letterState
                });
            }

            // Log duplicate letters
            console.log('\n=== DUPLICATE LETTERS ===');
            Object.entries(letterMapping).forEach(([letter, positions]) => {
                if (positions.length > 1) {
                    console.log(`"${letter}": ${positions.length} occurrences at positions:`,
                        positions.map(p => p.index));
                }
            });
        }

        // ========================================
        // FLOATING LETTER PARTICLES
        // ========================================
        function createFloatingLetters() {
            floatingLetters = [];
            const uniqueLetters = Object.keys(letterMapping);

            uniqueLetters.forEach(letter => {
                const count = letterMapping[letter].length;

                // Create one particle for each occurrence
                for (let i = 0; i < count; i++) {
                    const size = LETTER_CONFIG.floating.minSize +
                                Math.random() * (LETTER_CONFIG.floating.maxSize - LETTER_CONFIG.floating.minSize);

                    // Create unique physics for each letter
                    // Determine if this letter is "light" or "heavy"
                    const physicsType = Math.random();
                    let speedMultiplier, vxRange, vyRange;

                    if (physicsType < 0.3) {
                        // Light and floaty (30% of letters)
                        speedMultiplier = 0.3 + Math.random() * 0.4; // 0.3 to 0.7
                        vxRange = speedMultiplier * (0.5 + Math.random() * 1.5); // Gentle horizontal drift
                        vyRange = speedMultiplier * (0.5 + Math.random() * 1.5); // Gentle vertical drift
                    } else if (physicsType < 0.6) {
                        // Medium speed (30% of letters)
                        speedMultiplier = 1.0 + Math.random() * 1.0; // 1.0 to 2.0
                        vxRange = speedMultiplier * (Math.random() * 2.0);
                        vyRange = speedMultiplier * (Math.random() * 2.0);
                    } else {
                        // Heavy and fast (40% of letters)
                        speedMultiplier = 2.0 + Math.random() * 2.0; // 2.0 to 4.0
                        vxRange = speedMultiplier * (0.5 + Math.random() * 1.5);
                        vyRange = speedMultiplier * (0.5 + Math.random() * 1.5);
                    }

                    // Independent horizontal and vertical velocities
                    // Randomize direction independently
                    const vx = (Math.random() - 0.5) * 2 * vxRange;
                    const vy = (Math.random() - 0.5) * 2 * vyRange;

                    const particle = {
                        letter: letter,
                        x: Math.random() * width,
                        y: Math.random() * floatingAreaHeight,
                        vx: vx,
                        vy: vy,
                        baseSpeed: Math.sqrt(vx * vx + vy * vy), // Store original speed magnitude
                        speedMultiplier: speedMultiplier, // Store for visual feedback
                        size: size,
                        weight: LETTER_CONFIG.floating.weight,
                        rotation: (Math.random() - 0.5) * 0.3,
                        rotationSpeed: (Math.random() - 0.5) * 0.02 * speedMultiplier, // Faster letters rotate more
                        isFloating: true,
                        isTransitioning: false,
                        transitionFrame: 0,
                        targetX: 0,
                        targetY: 0,
                        targetSize: LETTER_CONFIG.placed.size,
                        targetWeight: LETTER_CONFIG.placed.weight,
                        targetRotation: 0,
                        startX: 0,
                        startY: 0,
                        startSize: size,
                        startWeight: LETTER_CONFIG.floating.weight,
                        startRotation: 0
                    };

                    floatingLetters.push(particle);
                }
            });

            console.log(`Created ${floatingLetters.length} floating letter particles`);
        }

        // ========================================
        // ANIMATION LOOP
        // ========================================
        function animate() {
            ctx.clearRect(0, 0, width, height);

            // Draw background division
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, width, floatingAreaHeight);

            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(0, sentenceAreaTop, width, height - sentenceAreaTop);

            // Update and draw floating letters
            floatingLetters.forEach(particle => {
                if (particle.isFloating) {
                    updateFloatingParticle(particle);
                } else if (particle.isTransitioning) {
                    updateTransitioningParticle(particle);
                }
                drawLetter(particle);
            });

            // Draw sentence area
            drawSentenceArea();

            requestAnimationFrame(animate);
        }

        function updateFloatingParticle(particle) {
            // Update position with unique velocity
            particle.x += particle.vx;
            particle.y += particle.vy;

            // Update rotation continuously based on speed
            particle.rotation += particle.rotationSpeed;

            // Bounce off walls with slight speed variation for chaos
            if (particle.x < 0 || particle.x > width) {
                particle.vx *= -1;
                particle.x = Math.max(0, Math.min(width, particle.x));

                // Add tiny random variation on bounce (chaos effect)
                particle.vx *= 0.98 + Math.random() * 0.04; // 98% to 102% of original
            }
            if (particle.y < 0 || particle.y > floatingAreaHeight) {
                particle.vy *= -1;
                particle.y = Math.max(0, Math.min(floatingAreaHeight, particle.y));

                // Add tiny random variation on bounce
                particle.vy *= 0.98 + Math.random() * 0.04;
            }
        }

        function updateTransitioningParticle(particle) {
            particle.transitionFrame++;
            const progress = particle.transitionFrame / LETTER_CONFIG.transition.duration;
            const eased = easeInOutCubic(progress);

            if (progress >= 1) {
                particle.x = particle.targetX;
                particle.y = particle.targetY;
                particle.size = particle.targetSize;
                particle.weight = particle.targetWeight;
                particle.rotation = particle.targetRotation;
                particle.isTransitioning = false;
            } else {
                particle.x = lerp(particle.startX, particle.targetX, eased);
                particle.y = lerp(particle.startY, particle.targetY, eased);
                particle.size = lerp(particle.startSize, particle.targetSize, eased);
                particle.weight = lerp(particle.startWeight, particle.targetWeight, eased);
                particle.rotation = lerp(particle.startRotation, particle.targetRotation, eased);
            }
        }

        function drawLetter(particle) {
            ctx.save();
            ctx.translate(particle.x, particle.y);
            ctx.rotate(particle.rotation);

            // Use serif for floating (organic), Helvetica for placed (geometric/mechanical)
            const fontFamily = particle.isFloating ?
                'Georgia, serif' :
                "'Helvetica Neue', Helvetica, Arial, sans-serif";
            ctx.font = `${particle.weight} ${particle.size}px ${fontFamily}`;

            // Vary opacity based on speed (faster = more opaque, slower = more ghostly)
            if (particle.isFloating) {
                const opacity = particle.speedMultiplier ?
                    Math.min(0.6 + particle.speedMultiplier * 0.15, 1.0) : 1.0;
                ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;

                // Vary shadow based on speed
                const shadowIntensity = particle.speedMultiplier ?
                    5 + particle.speedMultiplier * 3 : 10;
                ctx.shadowBlur = shadowIntensity;
                ctx.shadowColor = `rgba(255, 255, 255, ${opacity * 0.4})`;
            } else {
                ctx.fillStyle = '#00ff88';
            }

            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            ctx.fillText(particle.letter, 0, 0);
            ctx.restore();
        }

        // ========================================
        // SENTENCE AREA RENDERING
        // ========================================
        function drawSentenceArea() {
            const baseY = sentenceAreaTop + (height - sentenceAreaTop) / 2;
            const letterWidth = 18;
            const letterSpacing = 2;

            // Calculate total width
            const totalWidth = letterStates.length * (letterWidth + letterSpacing);
            let currentX = (width - totalWidth) / 2;

            letterStates.forEach((letterState, idx) => {
                const charX = currentX + letterWidth / 2;

                // Draw placeholder box for letters (not spaces/punctuation)
                if (!letterState.isSpace && !letterState.isPunctuation) {
                    ctx.strokeStyle = letterState.filled ? '#00ff88' : '#444';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(currentX, baseY - 20, letterWidth, 40);
                }

                // Draw placed letters or punctuation/spaces
                if (letterState.filled && (letterState.isSpace || letterState.isPunctuation)) {
                    ctx.font = "300 24px 'Helvetica Neue', Helvetica, Arial, sans-serif";
                    ctx.fillStyle = '#888';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(letterState.char, charX, baseY);
                }

                currentX += letterWidth + letterSpacing;
            });

            // Check completion
            checkAllLettersPlaced();
        }

        function checkAllLettersPlaced() {
            const allComplete = letterStates.every(s => s.filled);
            if (allComplete && !allLettersPlaced) {
                allLettersPlaced = true;
                showCompletionOverlay();
            }
        }

        function showCompletionOverlay() {
            const overlay = document.getElementById('completionOverlay');
            const sentenceEl = document.getElementById('completedSentence');
            sentenceEl.textContent = SENTENCE;
            overlay.classList.add('show');

            sentenceEl.onclick = () => {
                speakFullSentence();
            };
        }

        // ========================================
        // CLICK INTERACTION
        // ========================================
        function handleClick(event) {
            if (allLettersPlaced) return;

            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            // Find nearest floating letter
            let nearestParticle = null;
            let nearestDist = Infinity;

            floatingLetters.forEach(particle => {
                if (!particle.isFloating) return;

                const dx = particle.x - mouseX;
                const dy = particle.y - mouseY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < nearestDist && dist < 100) { // Within 100px
                    nearestDist = dist;
                    nearestParticle = particle;
                }
            });

            if (nearestParticle) {
                placeLetter(nearestParticle);
            }
        }

        function placeLetter(particle) {
            const letter = particle.letter;
            const targets = letterMapping[letter];

            // Find first unfilled target
            const target = targets.find(t => !t.filled);
            if (!target) return;

            // Mark as filled
            target.filled = true;
            target.stateRef.filled = true;
            target.stateRef.particle = particle;

            // Calculate target position
            const letterWidth = 18;
            const letterSpacing = 2;
            const totalWidth = letterStates.length * (letterWidth + letterSpacing);
            const startX = (width - totalWidth) / 2;

            const targetX = startX + (target.index * (letterWidth + letterSpacing)) + letterWidth / 2;
            const baseY = sentenceAreaTop + (height - sentenceAreaTop) / 2;

            // Start transition
            particle.isFloating = false;
            particle.isTransitioning = true;
            particle.transitionFrame = 0;
            particle.startX = particle.x;
            particle.startY = particle.y;
            particle.startSize = particle.size;
            particle.startWeight = particle.weight;
            particle.startRotation = particle.rotation;
            particle.targetX = targetX;
            particle.targetY = baseY;
            particle.targetSize = LETTER_CONFIG.placed.size;
            particle.targetWeight = LETTER_CONFIG.placed.weight;
            particle.targetRotation = 0;

            // Pronounce the letter
            speakLetter(letter);
        }

        // ========================================
        // WEB SPEECH API
        // ========================================
        function loadVoices() {
            if (!window.speechSynthesis) return;

            // Load voices (may take time on some browsers)
            const loadVoicesAsync = () => {
                availableVoices = speechSynthesis.getVoices();

                if (availableVoices.length > 0) {
                    // Find German male voice
                    germanMaleVoice = availableVoices.find(voice =>
                        voice.lang.startsWith('de') &&
                        (voice.name.toLowerCase().includes('male') ||
                         voice.name.toLowerCase().includes('mann') ||
                         voice.name.toLowerCase().includes('hans') ||
                         voice.name.toLowerCase().includes('markus'))
                    );

                    // Fallback to any German voice
                    if (!germanMaleVoice) {
                        germanMaleVoice = availableVoices.find(voice =>
                            voice.lang.startsWith('de')
                        );
                    }

                    console.log('\n=== AVAILABLE VOICES ===');
                    console.log('German voices:', availableVoices.filter(v => v.lang.startsWith('de')));
                    console.log('Selected German voice:', germanMaleVoice);
                }
            };

            loadVoicesAsync();

            // Voices may load asynchronously
            if (speechSynthesis.onvoiceschanged !== undefined) {
                speechSynthesis.onvoiceschanged = loadVoicesAsync;
            }
        }

        function speakLetter(letter) {
            if (!window.speechSynthesis) return;

            const utterance = new SpeechSynthesisUtterance(letter);
            utterance.lang = 'de-DE'; // German pronunciation for absurdist effect

            // Randomize pitch and rate for chaotic, varied sounds
            utterance.pitch = 0.6 + Math.random() * 1.0; // Range: 0.6 to 1.6
            utterance.rate = 0.7 + Math.random() * 0.8;  // Range: 0.7 to 1.5
            utterance.volume = 0.8 + Math.random() * 0.2; // Range: 0.8 to 1.0

            // Randomly select from available German voices for variety
            if (availableVoices.length > 0) {
                const germanVoices = availableVoices.filter(v => v.lang.startsWith('de'));
                if (germanVoices.length > 0) {
                    const randomVoice = germanVoices[Math.floor(Math.random() * germanVoices.length)];
                    utterance.voice = randomVoice;
                }
            }

            speechSynthesis.cancel(); // Cancel any ongoing speech
            speechSynthesis.speak(utterance);
        }

        function speakFullSentence() {
            if (!window.speechSynthesis) return;

            const utterance = new SpeechSynthesisUtterance(SENTENCE);
            utterance.lang = 'de-DE'; // German pronunciation of French text (absurdist)

            // Mechanical/robotic parameters
            utterance.pitch = 0.8;  // Lower pitch for mechanical tone
            utterance.rate = 0.9;   // Steady, deliberate pace
            utterance.volume = 1.0;

            // Use selected German male voice for cold, mechanical delivery
            if (germanMaleVoice) {
                utterance.voice = germanMaleVoice;
                console.log('Speaking with voice:', germanMaleVoice.name);
            }

            speechSynthesis.cancel();
            speechSynthesis.speak(utterance);
        }

        // ========================================
        // UTILITY FUNCTIONS
        // ========================================
        function lerp(start, end, t) {
            return start + (end - start) * t;
        }

        function easeInOutCubic(t) {
            return t < 0.5
                ? 4 * t * t * t
                : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        // ========================================
        // START APPLICATION
        // ========================================
        init();
    </script>
</body>
</html>
