<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>L'absurde</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', 'Times New Roman', serif;
            overflow: hidden;
            background: #000000;
        }

        #canvas {
            display: block;
            cursor: default;
        }

        .completion-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 10;
            backdrop-filter: blur(10px);
        }

        .completion-overlay.show {
            display: flex;
            animation: fadeIn 1.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        #completedSentence {
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            font-weight: 200;
            font-size: 42px;
            letter-spacing: 0.02em;
            padding: 0 60px;
            max-width: 85vw;
            color: #ffffff;
            cursor: pointer;
            text-align: center;
            line-height: 1.6;
            transition: opacity 0.3s ease;
        }

        #completedSentence:hover {
            opacity: 0.7;
        }

        @media (max-width: 600px) {
            #completedSentence {
                font-size: 22px;
                padding: 0 30px;
                letter-spacing: 0.01em;
            }
        }

        @media (min-width: 601px) and (max-width: 1024px) {
            #completedSentence {
                font-size: 32px;
                padding: 0 40px;
            }
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>
    <div class="completion-overlay" id="completionOverlay">
        <div id="completedSentence"></div>
    </div>

    <script>
        // ========================================
        // CONFIGURATION
        // ========================================
        const SENTENCE = "Aujourd'hui, maman est morte. Ou peut-être hier.";
        const FLOATING_AREA_RATIO = 0.75; // 75% for floating, 25% for sentence area
        const SENTENCE_VERTICAL_POSITION = 0.82; // Position sentence at 82% down the viewport
        const STORAGE_KEY = 'absurde_letterings';

        // Custom letterings
        let customLetterings = {}; // { char: Image }
        let letteringImages = {}; // { char: HTMLImageElement }

        const LETTER_CONFIG_BASE = {
            floating: {
                minSize: 60,
                maxSize: 80,
                weight: 700,
                style: 'normal'
            },
            placed: {
                size: 28,
                weight: 300,
                style: 'normal'
            },
            transition: {
                duration: 30 // frames
            },
            collision: {
                restitution: 0.4, // Low elasticity for soft bounces (0-1)
                damping: 0.98, // Gentle velocity damping for smooth motion
                rotationFactor: 0.008 // How much collision affects rotation
            }
        };

        // Responsive letter config with getters
        const LETTER_CONFIG = {
            get floating() {
                const scale = getResponsiveScale();
                return {
                    minSize: LETTER_CONFIG_BASE.floating.minSize * scale.floating,
                    maxSize: LETTER_CONFIG_BASE.floating.maxSize * scale.floating,
                    weight: LETTER_CONFIG_BASE.floating.weight,
                    style: LETTER_CONFIG_BASE.floating.style
                };
            },
            get placed() {
                const scale = getResponsiveScale();
                return {
                    size: LETTER_CONFIG_BASE.placed.size * scale.placed,
                    weight: LETTER_CONFIG_BASE.placed.weight,
                    style: LETTER_CONFIG_BASE.placed.style
                };
            },
            get transition() {
                return LETTER_CONFIG_BASE.transition;
            }
        };

        // ========================================
        // GLOBAL STATE
        // ========================================
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width, height;
        let floatingAreaHeight, sentenceAreaTop;

        // Data structures
        let letterMapping = {}; // letter -> array of target positions
        let letterStates = []; // array of letter position objects
        let floatingLetters = []; // array of floating letter particles
        let allLettersPlaced = false;
        let germanMaleVoice = null; // German male voice for final sentence
        let availableVoices = []; // All available voices

        // Placement tracking for progressive color fade
        let totalLettersPlaced = 0;
        let totalLettersNeeded = 0;

        // Drag state
        let draggedParticle = null;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let wasDragging = false; // Track if we just finished dragging

        // ========================================
        // RESPONSIVE UTILITIES
        // ========================================
        function getResponsiveScale() {
            const screenWidth = window.innerWidth;

            // Mobile: < 600px
            if (screenWidth < 600) {
                return {
                    floating: 0.4,  // 40% of base size
                    placed: 0.5,    // 50% of base size
                    letterWidth: 0.5,
                    letterSpacing: 0.5
                };
            }
            // Tablet: 600-1024px
            else if (screenWidth < 1024) {
                return {
                    floating: 0.65,
                    placed: 0.75,
                    letterWidth: 0.75,
                    letterSpacing: 0.75
                };
            }
            // Desktop: >= 1024px
            else {
                return {
                    floating: 1.0,
                    placed: 1.0,
                    letterWidth: 1.0,
                    letterSpacing: 1.0
                };
            }
        }

        function getResponsiveLetterDimensions() {
            const scale = getResponsiveScale();
            const baseLetterWidth = 18;
            const baseLetterSpacing = 2;

            return {
                letterWidth: baseLetterWidth * scale.letterWidth,
                letterSpacing: baseLetterSpacing * scale.letterSpacing
            };
        }

        // ========================================
        // INITIALIZATION
        // ========================================
        async function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Add mouse event listeners for drag and click
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('click', handleClick);

            // Add touch event listeners for mobile
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd, { passive: false });

            // Load voices
            loadVoices();

            // Load custom letterings from localStorage
            await loadCustomLetterings();

            // Step 1: Decompose sentence and create mappings
            decomposeSentence();

            // Step 2: Create floating letter particles
            createFloatingLetters();

            // Step 3: Start animation loop
            animate();

            console.log('=== LETTER MAPPING ===');
            console.log(letterMapping);
            console.log('\n=== LETTER STATES ===');
            console.log(letterStates);
            console.log('\n=== CUSTOM LETTERINGS ===');
            console.log('Loaded custom letterings for:', Object.keys(letteringImages));
        }

        async function loadCustomLetterings() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved) {
                    customLetterings = JSON.parse(saved);

                    // Load each image
                    const loadPromises = Object.entries(customLetterings).map(([char, dataURL]) => {
                        return new Promise((resolve, reject) => {
                            const img = new Image();
                            img.onload = () => {
                                letteringImages[char] = img;
                                resolve();
                            };
                            img.onerror = reject;
                            img.src = dataURL;
                        });
                    });

                    await Promise.all(loadPromises);
                    console.log(`Loaded ${Object.keys(letteringImages).length} custom letterings`);
                }
            } catch (e) {
                console.error('Failed to load custom letterings:', e);
            }
        }

        function hasCustomLettering(letter) {
            // Check if custom lettering exists for this letter
            return letteringImages.hasOwnProperty(letter) && letteringImages[letter] !== null;
        }

        function resizeCanvas() {
            const oldWidth = width;
            const oldHeight = height;

            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            floatingAreaHeight = height * FLOATING_AREA_RATIO;
            sentenceAreaTop = floatingAreaHeight;

            // If this is a resize (not initial load), update positions
            if (oldWidth && oldHeight) {
                updatePositionsAfterResize(oldWidth, oldHeight);
            }
        }

        function updatePositionsAfterResize(oldWidth, oldHeight) {
            // 1. Constrain floating letters to new bounds
            floatingLetters.forEach(particle => {
                if (particle.isFloating) {
                    // Scale position proportionally
                    particle.x = (particle.x / oldWidth) * width;
                    particle.y = (particle.y / (oldHeight * FLOATING_AREA_RATIO)) * floatingAreaHeight;

                    // Ensure within bounds
                    particle.x = Math.max(0, Math.min(width, particle.x));
                    particle.y = Math.max(0, Math.min(floatingAreaHeight, particle.y));
                }
            });

            // 2. Recalculate positions for placed/transitioning letters
            floatingLetters.forEach(particle => {
                if (!particle.isFloating || particle.isTransitioning) {
                    // Find which letter state this particle is associated with
                    const targetIndex = findTargetIndexForParticle(particle);

                    if (targetIndex !== -1) {
                        const { letterWidth, letterSpacing } = getResponsiveLetterDimensions();
                        const totalWidth = letterStates.length * (letterWidth + letterSpacing);
                        const startX = (width - totalWidth) / 2;
                        const targetX = startX + (targetIndex * (letterWidth + letterSpacing)) + letterWidth / 2;
                        const baseY = sentenceAreaTop + (height - sentenceAreaTop) / 2;

                        // Update target position
                        particle.targetX = targetX;
                        particle.targetY = baseY;

                        // If already placed (not transitioning), update current position immediately
                        if (!particle.isTransitioning) {
                            particle.x = targetX;
                            particle.y = baseY;
                        }

                        // Update target size based on new responsive scale
                        const placedConfig = LETTER_CONFIG.placed;
                        particle.targetSize = placedConfig.size;
                        if (!particle.isTransitioning) {
                            particle.size = placedConfig.size;
                        }
                    }
                }
            });
        }

        function findTargetIndexForParticle(particle) {
            // Find which position in letterStates this particle occupies
            for (let i = 0; i < letterStates.length; i++) {
                if (letterStates[i].particle === particle) {
                    return i;
                }
            }
            return -1;
        }

        // ========================================
        // FRENCH LETTER DECOMPOSITION & MAPPING
        // ========================================
        function isSpecialCharacter(char) {
            // Check if character is punctuation or special character
            // Include: spaces, hyphens, apostrophes, commas, periods, etc.
            const specialChars = /[^a-zA-ZÀ-ÿ]/; // Everything except letters (including accented)
            return specialChars.test(char);
        }

        function decomposeSentence() {
            letterMapping = {};
            letterStates = [];

            // Decompose into individual characters
            for (let i = 0; i < SENTENCE.length; i++) {
                const char = SENTENCE[i];

                const isSpecial = isSpecialCharacter(char);

                const letterState = {
                    char: char,
                    index: i,
                    filled: false,
                    particle: null,
                    isSpace: char === ' ',
                    isPunctuation: isSpecial && char !== ' ' // Any special char that's not a space
                };

                letterStates.push(letterState);

                // Skip spaces and all special characters from mapping (they're auto-complete)
                if (isSpecial) {
                    letterState.filled = true;
                    continue;
                }

                // Only add alphabetic letters to the mapping
                if (!letterMapping[char]) {
                    letterMapping[char] = [];
                }

                letterMapping[char].push({
                    index: i,
                    char: char,
                    filled: false,
                    stateRef: letterState
                });
            }

            // Calculate total letters needed (non-space, non-punctuation)
            totalLettersNeeded = Object.values(letterMapping).reduce((sum, arr) => sum + arr.length, 0);

            // Log statistics
            console.log('\n=== LETTER STATISTICS ===');
            console.log('Total characters in sentence:', SENTENCE.length);
            console.log('Alphabetic letters (floating):', Object.keys(letterMapping).length, 'unique');
            console.log('Total letter instances:', totalLettersNeeded);
            console.log('Special characters (auto-filled):', letterStates.filter(s => s.isSpace || s.isPunctuation).length);

            console.log('\n=== DUPLICATE LETTERS ===');
            Object.entries(letterMapping).forEach(([letter, positions]) => {
                if (positions.length > 1) {
                    console.log(`"${letter}": ${positions.length} occurrences at positions:`,
                        positions.map(p => p.index));
                }
            });

            console.log('\n=== SPECIAL CHARACTERS (NOT FLOATING) ===');
            const specialChars = letterStates.filter(s => s.isSpace || s.isPunctuation);
            console.log('Characters excluded from floating:', specialChars.map(s => s.char).join(''));
        }

        // ========================================
        // FLOATING LETTER PARTICLES
        // ========================================
        function createFloatingLetters() {
            floatingLetters = [];
            const uniqueLetters = Object.keys(letterMapping);

            uniqueLetters.forEach(letter => {
                const count = letterMapping[letter].length;

                // Create one particle for each occurrence
                for (let i = 0; i < count; i++) {
                    const size = LETTER_CONFIG.floating.minSize +
                        Math.random() * (LETTER_CONFIG.floating.maxSize - LETTER_CONFIG.floating.minSize);

                    // Create unique physics for each letter
                    // Determine if this letter is "light" or "heavy"
                    const physicsType = Math.random();
                    let speedMultiplier, vxRange, vyRange;

                    if (physicsType < 0.3) {
                        // Light and floaty (30% of letters)
                        speedMultiplier = 0.3 + Math.random() * 0.4; // 0.3 to 0.7
                        vxRange = speedMultiplier * (0.5 + Math.random() * 1.5); // Gentle horizontal drift
                        vyRange = speedMultiplier * (0.5 + Math.random() * 1.5); // Gentle vertical drift
                    } else if (physicsType < 0.6) {
                        // Medium speed (30% of letters)
                        speedMultiplier = 1.0 + Math.random() * 1.0; // 1.0 to 2.0
                        vxRange = speedMultiplier * (Math.random() * 2.0);
                        vyRange = speedMultiplier * (Math.random() * 2.0);
                    } else {
                        // Heavy and fast (40% of letters)
                        speedMultiplier = 2.0 + Math.random() * 2.0; // 2.0 to 4.0
                        vxRange = speedMultiplier * (0.5 + Math.random() * 1.5);
                        vyRange = speedMultiplier * (0.5 + Math.random() * 1.5);
                    }

                    // Independent horizontal and vertical velocities
                    // Randomize direction independently
                    const vx = (Math.random() - 0.5) * 2 * vxRange;
                    const vy = (Math.random() - 0.5) * 2 * vyRange;

                    const particle = {
                        letter: letter,
                        x: Math.random() * width,
                        y: Math.random() * floatingAreaHeight,
                        vx: vx,
                        vy: vy,
                        baseSpeed: Math.sqrt(vx * vx + vy * vy), // Store original speed magnitude
                        speedMultiplier: speedMultiplier, // Store for visual feedback
                        size: size,
                        weight: LETTER_CONFIG.floating.weight,
                        rotation: (Math.random() - 0.5) * 0.3,
                        rotationSpeed: (Math.random() - 0.5) * 0.02 * speedMultiplier, // Faster letters rotate more
                        isFloating: true,
                        isTransitioning: false,
                        isDragging: false,
                        transitionFrame: 0,
                        targetX: 0,
                        targetY: 0,
                        targetSize: LETTER_CONFIG.placed.size,
                        targetWeight: LETTER_CONFIG.placed.weight,
                        targetRotation: 0,
                        startX: 0,
                        startY: 0,
                        startSize: size,
                        startWeight: LETTER_CONFIG.floating.weight,
                        startRotation: 0,
                        // Color properties
                        color: null, // Will be assigned when dragged
                        originalColor: null, // Store the original assigned color
                        colorFadeStartTime: null, // Deprecated - now using placementOrder
                        fontFamilyTransition: 0, // 0 = Georgia, 1 = Helvetica
                        placementOrder: null, // Order in which letter was placed (for progressive fade)
                        // Interaction tracking
                        wasDragged: false, // Track if letter was dragged
                        wasClicked: false, // Track if letter was clicked and placed
                        dropTime: null, // Time when letter was dropped (for drag fade)
                        lastVoiceTime: null, // Track when voice was last played (for cooldown)
                        useHelveticaFallback: false, // For custom letters: temporarily use Helvetica during/after drag
                        revertTimer: null, // Timer to revert custom letters back from Helvetica
                        // Drag physics
                        dragTargetX: 0, // Mouse position for spring physics
                        dragTargetY: 0,
                        dragVx: 0, // Velocity tracking during drag
                        dragVy: 0,
                        lastDragX: 0, // Previous mouse position for velocity calculation
                        lastDragY: 0
                    };

                    floatingLetters.push(particle);
                }
            });

            console.log(`Created ${floatingLetters.length} floating letter particles`);
        }

        // ========================================
        // TIME-BASED COLOR FADE SYSTEM FOR PLACED LETTERS
        // ========================================
        function updateAllPlacedLetterColors() {
            // Update colors for all placed letters with time-based fade
            // Each letter fades from its assigned color to white over 15-20 seconds

            const now = Date.now();

            floatingLetters.forEach(particle => {
                // Only update placed letters that were clicked (not dragged)
                if (particle.wasClicked && particle.placementTime && particle.originalColor) {
                    const elapsed = (now - particle.placementTime) / 1000; // seconds
                    const FADE_DURATION = 17.5; // 17.5 seconds (midpoint of 15-20) for organic fade

                    if (elapsed < FADE_DURATION) {
                        // Still fading: interpolate from original color to white with easing
                        const fadeProgress = elapsed / FADE_DURATION;
                        const easedProgress = easeInOutCubic(fadeProgress); // Smooth, natural fade
                        particle.color = interpolateColorToWhite(particle.originalColor, easedProgress);
                    } else {
                        // Fade complete: keep white permanently
                        particle.color = 'hsl(0, 0%, 100%)'; // Pure white
                    }
                }
            });
        }

        // ========================================
        // COLLISION DETECTION & PHYSICS
        // ========================================
        function handleCollisions() {
            // Only check collisions between floating particles
            const floatingParticles = floatingLetters.filter(p => p.isFloating && !p.isDragging);

            // Optimization: Use spatial grid to reduce collision checks
            // Grid cell size based on largest letter size
            const cellSize = LETTER_CONFIG_BASE.floating.maxSize * 2;
            const grid = {};

            // Assign particles to grid cells
            floatingParticles.forEach(p => {
                const cellX = Math.floor(p.x / cellSize);
                const cellY = Math.floor(p.y / cellSize);
                const key = `${cellX},${cellY}`;

                if (!grid[key]) grid[key] = [];
                grid[key].push(p);
            });

            // Check collisions only within same and neighboring cells
            Object.values(grid).forEach(cell => {
                // Check all pairs within this cell
                for (let i = 0; i < cell.length; i++) {
                    for (let j = i + 1; j < cell.length; j++) {
                        checkAndResolveCollision(cell[i], cell[j]);
                    }
                }
            });
        }

        function checkAndResolveCollision(p1, p2) {
            // Calculate distance between centers
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // Calculate collision radius (approximate based on font size)
            // Letters are roughly circular, radius is about half the font size
            const radius1 = p1.size / 2.5; // Slightly smaller hitbox for more natural feel
            const radius2 = p2.size / 2.5;
            const minDistance = radius1 + radius2;

            // Check for collision
            if (distance < minDistance && distance > 0.1) {
                // Collision detected! Apply elastic collision physics

                // Normalize the collision vector
                const nx = dx / distance;
                const ny = dy / distance;

                // Relative velocity
                const dvx = p2.vx - p1.vx;
                const dvy = p2.vy - p1.vy;

                // Relative velocity in collision normal direction
                const dvn = dvx * nx + dvy * ny;

                // Don't process if particles are moving apart
                if (dvn >= 0) return;

                // Use configured restitution for soft, natural bounces
                const restitution = LETTER_CONFIG_BASE.collision.restitution;

                // Calculate impulse magnitude for equal mass particles
                // impulse = -(1 + restitution) * relativeVelocityAlongNormal / 2
                const impulseMagnitude = -(1 + restitution) * dvn / 2;

                // Apply impulse to both particles
                const impulseX = impulseMagnitude * nx;
                const impulseY = impulseMagnitude * ny;

                p1.vx -= impulseX;
                p1.vy -= impulseY;
                p2.vx += impulseX;
                p2.vy += impulseY;

                // Separate overlapping particles gently to prevent jittery behavior
                const overlap = minDistance - distance;
                const separationRatio = 0.6; // Gentler separation for smoother deflection
                const separationX = (overlap * separationRatio / 2) * nx;
                const separationY = (overlap * separationRatio / 2) * ny;

                p1.x -= separationX;
                p1.y -= separationY;
                p2.x += separationX;
                p2.y += separationY;

                // Add slight rotation based on tangential impact for organic feel
                // Tangent vector perpendicular to normal
                const tx = -ny;
                const ty = nx;

                // Tangential velocity component
                const dvt = dvx * tx + dvy * ty;

                // Apply rotational impulse using configured factor
                const rotationImpulse = dvt * LETTER_CONFIG_BASE.collision.rotationFactor;
                p1.rotationSpeed += rotationImpulse;
                p2.rotationSpeed -= rotationImpulse;

                // Apply gentle damping to rotation
                p1.rotationSpeed *= 0.98;
                p2.rotationSpeed *= 0.98;

                // Clamp rotation speed to prevent excessive spinning
                const maxRotationSpeed = 0.06;
                p1.rotationSpeed = Math.max(-maxRotationSpeed, Math.min(maxRotationSpeed, p1.rotationSpeed));
                p2.rotationSpeed = Math.max(-maxRotationSpeed, Math.min(maxRotationSpeed, p2.rotationSpeed));
            }
        }

        // ========================================
        // ANIMATION LOOP
        // ========================================
        function animate() {
            // Draw sophisticated black gradient background
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, '#000000');
            gradient.addColorStop(0.5, '#0a0a0a');
            gradient.addColorStop(1, '#000000');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);

            // Draw subtle dividing line for sentence area
            const lineY = height * SENTENCE_VERTICAL_POSITION - 40;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(width * 0.1, lineY);
            ctx.lineTo(width * 0.9, lineY);
            ctx.stroke();

            // Update and draw floating letters
            floatingLetters.forEach(particle => {
                if (particle.isDragging) {
                    updateDraggingParticle(particle);
                } else if (particle.isFloating) {
                    updateFloatingParticle(particle);
                } else if (particle.isTransitioning) {
                    updateTransitioningParticle(particle);
                }
                drawLetter(particle);
            });

            // Handle collisions between floating letters
            handleCollisions();

            // Update time-based color fades for placed letters
            updateAllPlacedLetterColors();

            // Draw sentence area
            drawSentenceArea();

            requestAnimationFrame(animate);
        }

        function updateFloatingParticle(particle) {
            // Update position with unique velocity
            particle.x += particle.vx;
            particle.y += particle.vy;

            // Update rotation continuously based on speed
            particle.rotation += particle.rotationSpeed;

            // Bounce off walls with damping and variation
            const wallDamping = 0.92; // Slight energy loss on wall bounce

            if (particle.x < 0 || particle.x > width) {
                particle.vx *= -wallDamping;
                particle.x = Math.max(0, Math.min(width, particle.x));

                // Add tiny random variation on bounce (chaos effect)
                const variation = 0.98 + Math.random() * 0.04; // 98% to 102%
                particle.vx *= variation;
            }
            if (particle.y < 0 || particle.y > floatingAreaHeight) {
                particle.vy *= -wallDamping;
                particle.y = Math.max(0, Math.min(floatingAreaHeight, particle.y));

                // Add tiny random variation on bounce
                const variation = 0.98 + Math.random() * 0.04;
                particle.vy *= variation;
            }

            // Apply gentle velocity damping
            particle.vx *= LETTER_CONFIG_BASE.collision.damping;
            particle.vy *= LETTER_CONFIG_BASE.collision.damping;

            // Handle time-based color and typeface fade for dragged letters
            if (particle.wasDragged && particle.dropTime) {
                const now = Date.now();
                const elapsed = (now - particle.dropTime) / 1000; // seconds

                const HOLD_DURATION = 10; // Hold Helvetica + color for 10 seconds
                const FADE_DURATION = 2.5; // Fade back over 2.5 seconds for smooth transition

                if (elapsed > HOLD_DURATION) {
                    const fadeProgress = Math.min((elapsed - HOLD_DURATION) / FADE_DURATION, 1.0);

                    // Apply easing for natural feel (ease-in-out)
                    const easedProgress = easeInOutCubic(fadeProgress);

                    // Fade font back from Helvetica (1.0) to original/Georgia (0.0)
                    particle.fontFamilyTransition = lerp(1.0, 0, easedProgress);

                    // Fade color back to white with easing
                    if (particle.originalColor && fadeProgress < 1.0) {
                        const color = interpolateColorToWhite(particle.originalColor, easedProgress);
                        particle.color = color;
                    } else if (fadeProgress >= 1.0) {
                        particle.color = null; // Fully white (will use default)
                        particle.wasDragged = false;
                        particle.dropTime = null;
                        particle.originalColor = null;
                        particle.fontFamilyTransition = 0; // Back to original
                    }
                }
            }
        }

        function updateDraggingParticle(particle) {
            // For DRAG: Transition to Helvetica while dragging
            particle.fontFamilyTransition = Math.min(particle.fontFamilyTransition + 0.05, 1.0);

            // Slight size increase while dragging
            const dragSize = particle.startSize * 1.2;
            particle.size = lerp(particle.size, dragSize, 0.2);

            // Spring physics: letter follows mouse with inertia
            const springStiffness = 0.25; // How quickly it follows (0-1, lower = more lag)
            const damping = 0.85; // Velocity damping (0-1, lower = more friction)

            // Calculate spring force toward target (mouse position)
            const dx = particle.dragTargetX - particle.x;
            const dy = particle.dragTargetY - particle.y;

            // Apply spring force to velocity
            particle.dragVx += dx * springStiffness;
            particle.dragVy += dy * springStiffness;

            // Apply damping to prevent oscillation
            particle.dragVx *= damping;
            particle.dragVy *= damping;

            // Update position based on velocity
            particle.x += particle.dragVx;
            particle.y += particle.dragVy;
        }

        function updateTransitioningParticle(particle) {
            particle.transitionFrame++;
            const progress = particle.transitionFrame / LETTER_CONFIG.transition.duration;
            const eased = easeInOutCubic(progress);

            if (progress >= 1) {
                particle.x = particle.targetX;
                particle.y = particle.targetY;
                particle.size = particle.targetSize;
                particle.weight = particle.targetWeight;
                particle.rotation = particle.targetRotation;
                particle.fontFamilyTransition = 1.0; // Fully Helvetica
                particle.isTransitioning = false;
            } else {
                particle.x = lerp(particle.startX, particle.targetX, eased);
                particle.y = lerp(particle.startY, particle.targetY, eased);
                particle.size = lerp(particle.startSize, particle.targetSize, eased);
                particle.weight = lerp(particle.startWeight, particle.targetWeight, eased);
                particle.rotation = lerp(particle.startRotation, particle.targetRotation, eased);
                particle.fontFamilyTransition = lerp(0, 1, eased); // Transition font
            }

            // Color is now managed by updateAllPlacedLetterColors() based on placement order
            // No time-based fade needed here
        }

        function drawLetter(particle) {
            ctx.save();
            ctx.translate(particle.x, particle.y);
            ctx.rotate(particle.rotation);

            // Check if custom lettering exists for this character
            const customImage = letteringImages[particle.letter];

            // Determine if we should use the custom image or Helvetica fallback
            const shouldUseCustomImage = customImage && !particle.useHelveticaFallback;

            if (shouldUseCustomImage) {
                // Draw custom hand-drawn glyph with 1.7x size increase
                const scale = (particle.size / 400) * 1.7; // 400 is the canvas size in lettering mode, 1.7x larger
                const drawWidth = customImage.width * scale;
                const drawHeight = customImage.height * scale;

                // Apply color tint if particle has color (dragging or placed)
                if (particle.color) {
                    // Parse HSL color for tinting
                    const match = particle.color.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
                    if (match) {
                        const h = parseInt(match[1]);
                        const s = parseInt(match[2]);
                        const l = parseInt(match[3]);

                        // Create a temporary canvas for color manipulation
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = drawWidth;
                        tempCanvas.height = drawHeight;
                        const tempCtx = tempCanvas.getContext('2d');

                        // Draw the image
                        tempCtx.drawImage(customImage, 0, 0, drawWidth, drawHeight);

                        // Apply color tint using globalCompositeOperation
                        tempCtx.globalCompositeOperation = 'source-atop';
                        tempCtx.fillStyle = particle.color;
                        tempCtx.fillRect(0, 0, drawWidth, drawHeight);

                        // Apply transformation effects when dragging or after drop (based on fontFamilyTransition)
                        // This creates a "geometric/mechanical" look as it transitions toward Helvetica
                        const transitionIntensity = particle.fontFamilyTransition; // 0 = original, 1 = Helvetica-like

                        // Add strong glow effect when dragging for better visibility
                        if (particle.isDragging || transitionIntensity > 0) {
                            const glowIntensity = 15 + (transitionIntensity * 10); // 15-25 based on transition
                            ctx.shadowBlur = glowIntensity;
                            ctx.shadowColor = particle.color;
                        }

                        // Increase opacity for more visible color change
                        ctx.globalAlpha = 1.0; // Full opacity

                        // Apply subtle contrast adjustment during transition for "cleaner" geometric look
                        if (transitionIntensity > 0) {
                            // Slightly sharpen/brighten for mechanical feel
                            ctx.filter = `contrast(${1 + transitionIntensity * 0.15}) brightness(${1 + transitionIntensity * 0.1})`;
                        }

                        // Draw the tinted image
                        ctx.drawImage(tempCanvas, -drawWidth / 2, -drawHeight / 2);

                        // Reset filters and alpha
                        ctx.filter = 'none';
                        ctx.globalAlpha = 1.0;
                    } else {
                        // Fallback: draw without tint
                        ctx.drawImage(customImage, -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight);
                    }
                } else {
                    // Draw without color tint (white glyph for floating letters)
                    const opacity = particle.speedMultiplier ?
                        Math.min(0.7 + particle.speedMultiplier * 0.1, 0.95) : 0.85;
                    ctx.globalAlpha = opacity;

                    // Add subtle glow for floating letters
                    if (particle.isFloating && !particle.isDragging) {
                        const shadowIntensity = particle.speedMultiplier ?
                            3 + particle.speedMultiplier * 2 : 5;
                        ctx.shadowBlur = shadowIntensity;
                        ctx.shadowColor = `rgba(255, 255, 255, ${opacity * 0.2})`;
                    }

                    // Draw the custom hand-drawn glyph
                    ctx.drawImage(customImage, -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight);

                    // Reset alpha for next draw
                    ctx.globalAlpha = 1.0;
                }
            } else {
                // Fallback to text rendering if no custom glyph exists
                // Interpolate between Georgia and Helvetica based on fontFamilyTransition
                const fontFamily = particle.fontFamilyTransition < 0.5 ?
                    'Georgia, serif' :
                    "'Helvetica Neue', Helvetica, Arial, sans-serif";
                ctx.font = `${particle.weight} ${particle.size}px ${fontFamily}`;

                // Determine color with refined palette
                let fillColor;

                if (particle.isFloating && !particle.isDragging && !particle.color) {
                    // Floating letters (not colored): pure white with opacity based on speed for depth
                    const opacity = particle.speedMultiplier ?
                        Math.min(0.7 + particle.speedMultiplier * 0.1, 0.95) : 0.85;
                    fillColor = `rgba(255, 255, 255, ${opacity})`;

                    // Subtle elegant glow
                    const shadowIntensity = particle.speedMultiplier ?
                        3 + particle.speedMultiplier * 2 : 5;
                    ctx.shadowBlur = shadowIntensity;
                    ctx.shadowColor = `rgba(255, 255, 255, ${opacity * 0.2})`;
                } else if (particle.color) {
                    // Colored letters: dragged or placed with progressive fade
                    fillColor = particle.color;

                    // Add strong glow when dragging or during transition
                    const transitionIntensity = particle.fontFamilyTransition; // 0 to 1
                    if (particle.isDragging || transitionIntensity > 0) {
                        const glowIntensity = 15 + (transitionIntensity * 10); // 15-25 based on transition
                        ctx.shadowBlur = glowIntensity;
                        ctx.shadowColor = particle.color;
                    }
                } else {
                    // Default: white
                    fillColor = 'rgba(255, 255, 255, 0.85)';
                }

                ctx.fillStyle = fillColor;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                ctx.fillText(particle.letter, 0, 0);
            }

            ctx.restore();
        }

        // ========================================
        // SENTENCE AREA RENDERING
        // ========================================
        function drawSentenceArea() {
            const baseY = height * SENTENCE_VERTICAL_POSITION;
            const { letterWidth, letterSpacing } = getResponsiveLetterDimensions();

            // Enhanced letter spacing for refined typography
            const refinedSpacing = letterSpacing * 1.5;

            // Calculate total width with refined spacing
            const totalWidth = letterStates.length * (letterWidth + refinedSpacing);
            let currentX = (width - totalWidth) / 2;

            letterStates.forEach((letterState, idx) => {
                const charX = currentX + letterWidth / 2;

                // Draw minimalist placeholder - subtle thin line underneath
                if (!letterState.isSpace && !letterState.isPunctuation) {
                    const lineY = baseY + 16;
                    const lineOpacity = letterState.filled ? 0.15 : 0.08;

                    ctx.strokeStyle = `rgba(255, 255, 255, ${lineOpacity})`;
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(currentX, lineY);
                    ctx.lineTo(currentX + letterWidth, lineY);
                    ctx.stroke();
                }

                // Draw placed letters or punctuation/spaces with refined styling
                if (letterState.filled && (letterState.isSpace || letterState.isPunctuation)) {
                    const placedConfig = LETTER_CONFIG.placed;
                    ctx.font = `${placedConfig.weight} ${placedConfig.size}px 'Helvetica Neue', Helvetica, Arial, sans-serif`;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(letterState.char, charX, baseY);
                }

                currentX += letterWidth + refinedSpacing;
            });

            // Check completion
            checkAllLettersPlaced();
        }

        function checkAllLettersPlaced() {
            const allComplete = letterStates.every(s => s.filled);
            if (allComplete && !allLettersPlaced) {
                allLettersPlaced = true;
                showCompletionOverlay();
            }
        }

        function showCompletionOverlay() {
            const overlay = document.getElementById('completionOverlay');
            const sentenceEl = document.getElementById('completedSentence');
            sentenceEl.textContent = SENTENCE;
            overlay.classList.add('show');

            sentenceEl.onclick = () => {
                speakFullSentence();
            };
        }

        // ========================================
        // MOUSE INTERACTION (DRAG & CLICK)
        // ========================================
        function generateRandomColor() {
            // Generate vibrant random colors
            const hue = Math.random() * 360;
            const saturation = 70 + Math.random() * 30; // 70-100%
            const lightness = 45 + Math.random() * 15; // 45-60%
            return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }

        function generateBrightColor() {
            // Generate bright, saturated colors for placed letters
            const hue = Math.random() * 360;
            const saturation = 75 + Math.random() * 25; // 75-100% for vivid colors
            const lightness = 50 + Math.random() * 15;  // 50-65% for good visibility
            return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }

        function findParticleAt(mouseX, mouseY) {
            let nearestParticle = null;
            let nearestDist = Infinity;

            floatingLetters.forEach(particle => {
                if (!particle.isFloating || particle.isDragging) return;

                const dx = particle.x - mouseX;
                const dy = particle.y - mouseY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < nearestDist && dist < 50) { // Within 50px
                    nearestDist = dist;
                    nearestParticle = particle;
                }
            });

            return nearestParticle;
        }

        function handleMouseDown(event) {
            if (allLettersPlaced) return;

            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            dragStartX = mouseX;
            dragStartY = mouseY;
            wasDragging = false;

            // Find particle to drag
            const particle = findParticleAt(mouseX, mouseY);

            if (particle) {
                draggedParticle = particle;
                isDragging = false; // Will become true on mouse move
            }
        }

        function handleMouseMove(event) {
            if (!draggedParticle) return;

            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            // Check if mouse moved enough to be considered a drag
            const dx = mouseX - dragStartX;
            const dy = mouseY - dragStartY;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist > 5 && !isDragging) {
                isDragging = true;
                wasDragging = true;
                draggedParticle.isDragging = true;
                draggedParticle.isFloating = false;

                // Initialize drag physics
                draggedParticle.dragTargetX = mouseX;
                draggedParticle.dragTargetY = mouseY;
                draggedParticle.lastDragX = mouseX;
                draggedParticle.lastDragY = mouseY;
                draggedParticle.dragVx = 0;
                draggedParticle.dragVy = 0;

                // Assign random color when drag actually starts
                if (!draggedParticle.color) {
                    const randomColor = generateRandomColor();
                    draggedParticle.color = randomColor;
                    draggedParticle.originalColor = randomColor; // Store for fade
                }

                // Check if this letter has custom lettering
                if (hasCustomLettering(draggedParticle.letter)) {
                    // Case B: Custom lettering exists - switch to Helvetica temporarily
                    draggedParticle.useHelveticaFallback = true;

                    // Cancel any existing revert timer
                    if (draggedParticle.revertTimer) {
                        clearTimeout(draggedParticle.revertTimer);
                        draggedParticle.revertTimer = null;
                    }
                }

                // Play voice when drag starts (with cooldown to avoid repetition)
                const now = Date.now();
                const VOICE_COOLDOWN = 2000; // 2 seconds cooldown
                if (!draggedParticle.lastVoiceTime || (now - draggedParticle.lastVoiceTime) > VOICE_COOLDOWN) {
                    speakLetter(draggedParticle.letter);
                    draggedParticle.lastVoiceTime = now;
                }
            }

            if (isDragging) {
                // Update drag target for spring physics
                draggedParticle.dragTargetX = mouseX;
                draggedParticle.dragTargetY = mouseY;
            }
        }

        function handleMouseUp(event) {
            if (!draggedParticle) return;

            if (isDragging) {
                // DRAG behavior: Drop at current position, keep floating with new color

                // Resume floating from current position
                draggedParticle.isDragging = false;
                draggedParticle.isFloating = true;

                // Inherit velocity from drag motion (with slight boost for natural feel)
                const velocityMultiplier = 1.2;
                draggedParticle.vx = draggedParticle.dragVx * velocityMultiplier;
                draggedParticle.vy = draggedParticle.dragVy * velocityMultiplier;

                // Clamp inherited velocity to prevent too fast movement
                const maxInheritedSpeed = 15;
                const currentSpeed = Math.sqrt(draggedParticle.vx ** 2 + draggedParticle.vy ** 2);
                if (currentSpeed > maxInheritedSpeed) {
                    const scale = maxInheritedSpeed / currentSpeed;
                    draggedParticle.vx *= scale;
                    draggedParticle.vy *= scale;
                }

                // Reset size back to original
                draggedParticle.size = draggedParticle.startSize;

                // Mark as dragged (color persists, but letter keeps floating)
                draggedParticle.wasDragged = true;
                draggedParticle.dropTime = Date.now();

                // If custom lettering exists, start 10-second timer to revert
                if (hasCustomLettering(draggedParticle.letter) && draggedParticle.useHelveticaFallback) {
                    draggedParticle.revertTimer = setTimeout(() => {
                        draggedParticle.useHelveticaFallback = false;
                        draggedParticle.revertTimer = null;
                    }, 10000); // 10 seconds
                }

                // Color persists (already assigned during drag start)
                // Font transition will fade back to original after 10 seconds
            } else {
                // Short click (no drag) - do nothing here, handleClick will handle it
            }

            draggedParticle = null;
            isDragging = false;
        }

        function handleClick(event) {
            // CLICK behavior: Place letter in correct position with Helvetica transformation
            if (allLettersPlaced) return;

            // Don't trigger click if we just finished dragging
            if (wasDragging) {
                wasDragging = false;
                return;
            }

            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            const nearestParticle = findParticleAt(mouseX, mouseY);

            if (nearestParticle) {
                // Assign random color immediately on click
                if (!nearestParticle.color) {
                    const randomColor = generateRandomColor();
                    nearestParticle.color = randomColor;
                    nearestParticle.originalColor = randomColor; // Store for fade
                }

                // Check if this letter has custom lettering
                if (hasCustomLettering(nearestParticle.letter)) {
                    // Case B: Custom lettering exists - switch to Helvetica for placement
                    nearestParticle.useHelveticaFallback = true;

                    // Cancel any existing revert timer (won't revert since it will be placed)
                    if (nearestParticle.revertTimer) {
                        clearTimeout(nearestParticle.revertTimer);
                        nearestParticle.revertTimer = null;
                    }
                }

                // Mark as clicked for color fade behavior
                nearestParticle.wasClicked = true;

                // Place letter in correct sentence position
                // This will transform to Helvetica and lock in place
                placeLetter(nearestParticle);
            }
        }

        // ========================================
        // TOUCH EVENT HANDLERS FOR MOBILE
        // ========================================
        function handleTouchStart(event) {
            event.preventDefault(); // Prevent scrolling
            if (allLettersPlaced) return;

            const touch = event.touches[0];
            const rect = canvas.getBoundingClientRect();
            const touchX = touch.clientX - rect.left;
            const touchY = touch.clientY - rect.top;

            dragStartX = touchX;
            dragStartY = touchY;
            wasDragging = false;

            // Find particle to drag
            const particle = findParticleAt(touchX, touchY);

            if (particle) {
                draggedParticle = particle;
                isDragging = false; // Will become true on touch move
            }
        }

        function handleTouchMove(event) {
            event.preventDefault(); // Prevent scrolling
            if (!draggedParticle) return;

            const touch = event.touches[0];
            const rect = canvas.getBoundingClientRect();
            const touchX = touch.clientX - rect.left;
            const touchY = touch.clientY - rect.top;

            // Check if touch moved enough to be considered a drag
            const dx = touchX - dragStartX;
            const dy = touchY - dragStartY;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist > 5 && !isDragging) {
                isDragging = true;
                wasDragging = true;
                draggedParticle.isDragging = true;
                draggedParticle.isFloating = false;

                // Initialize drag physics
                draggedParticle.dragTargetX = touchX;
                draggedParticle.dragTargetY = touchY;
                draggedParticle.lastDragX = touchX;
                draggedParticle.lastDragY = touchY;
                draggedParticle.dragVx = 0;
                draggedParticle.dragVy = 0;

                // Assign random color when drag starts
                if (!draggedParticle.color) {
                    const randomColor = generateRandomColor();
                    draggedParticle.color = randomColor;
                    draggedParticle.originalColor = randomColor;
                }

                // Check if this letter has custom lettering
                if (hasCustomLettering(draggedParticle.letter)) {
                    // Case B: Custom lettering exists - switch to Helvetica temporarily
                    draggedParticle.useHelveticaFallback = true;

                    // Cancel any existing revert timer
                    if (draggedParticle.revertTimer) {
                        clearTimeout(draggedParticle.revertTimer);
                        draggedParticle.revertTimer = null;
                    }
                }

                // Play voice when drag starts
                const now = Date.now();
                const VOICE_COOLDOWN = 2000;
                if (!draggedParticle.lastVoiceTime || (now - draggedParticle.lastVoiceTime) > VOICE_COOLDOWN) {
                    speakLetter(draggedParticle.letter);
                    draggedParticle.lastVoiceTime = now;
                }
            }

            if (isDragging) {
                // Update drag target for spring physics
                draggedParticle.dragTargetX = touchX;
                draggedParticle.dragTargetY = touchY;
            }
        }

        function handleTouchEnd(event) {
            event.preventDefault();
            if (!draggedParticle) return;

            if (isDragging) {
                // DRAG behavior: Drop at current position, keep floating with new color

                // Resume floating from current position
                draggedParticle.isDragging = false;
                draggedParticle.isFloating = true;

                // Inherit velocity from drag motion
                const velocityMultiplier = 1.2;
                draggedParticle.vx = draggedParticle.dragVx * velocityMultiplier;
                draggedParticle.vy = draggedParticle.dragVy * velocityMultiplier;

                // Clamp inherited velocity
                const maxInheritedSpeed = 15;
                const currentSpeed = Math.sqrt(draggedParticle.vx ** 2 + draggedParticle.vy ** 2);
                if (currentSpeed > maxInheritedSpeed) {
                    const scale = maxInheritedSpeed / currentSpeed;
                    draggedParticle.vx *= scale;
                    draggedParticle.vy *= scale;
                }

                // Reset size back to original
                draggedParticle.size = draggedParticle.startSize;

                // Mark as dragged
                draggedParticle.wasDragged = true;
                draggedParticle.dropTime = Date.now();

                // If custom lettering exists, start 10-second timer to revert
                if (hasCustomLettering(draggedParticle.letter) && draggedParticle.useHelveticaFallback) {
                    draggedParticle.revertTimer = setTimeout(() => {
                        draggedParticle.useHelveticaFallback = false;
                        draggedParticle.revertTimer = null;
                    }, 10000); // 10 seconds
                }
            } else {
                // Short tap - trigger click behavior
                const touch = event.changedTouches[0];
                const rect = canvas.getBoundingClientRect();
                const touchX = touch.clientX - rect.left;
                const touchY = touch.clientY - rect.top;

                const nearestParticle = findParticleAt(touchX, touchY);

                if (nearestParticle) {
                    // Assign random color immediately
                    if (!nearestParticle.color) {
                        const randomColor = generateRandomColor();
                        nearestParticle.color = randomColor;
                        nearestParticle.originalColor = randomColor;
                    }

                    // Check if this letter has custom lettering
                    if (hasCustomLettering(nearestParticle.letter)) {
                        // Case B: Custom lettering exists - switch to Helvetica for placement
                        nearestParticle.useHelveticaFallback = true;

                        // Cancel any existing revert timer (won't revert since it will be placed)
                        if (nearestParticle.revertTimer) {
                            clearTimeout(nearestParticle.revertTimer);
                            nearestParticle.revertTimer = null;
                        }
                    }

                    // Mark as clicked
                    nearestParticle.wasClicked = true;

                    // Place letter in correct sentence position
                    placeLetter(nearestParticle);
                }
            }

            draggedParticle = null;
            isDragging = false;
        }

        function placeLetter(particle) {
            const letter = particle.letter;
            const targets = letterMapping[letter];

            // Find first unfilled target
            const target = targets.find(t => !t.filled);
            if (!target) return;

            // Mark as filled
            target.filled = true;
            target.stateRef.filled = true;
            target.stateRef.particle = particle;

            // Assign random bright color when first placed (if not already colored from drag)
            if (!particle.originalColor) {
                particle.originalColor = generateBrightColor();
                particle.color = particle.originalColor;
            }

            // Mark as clicked for color fade behavior
            particle.wasClicked = true;

            // Record placement time for time-based fade
            particle.placementTime = Date.now();

            // Assign placement order (increments with each placed letter)
            totalLettersPlaced++;
            particle.placementOrder = totalLettersPlaced;

            // Calculate target position using responsive dimensions with refined spacing
            const { letterWidth, letterSpacing } = getResponsiveLetterDimensions();
            const refinedSpacing = letterSpacing * 1.5;
            const totalWidth = letterStates.length * (letterWidth + refinedSpacing);
            const startX = (width - totalWidth) / 2;

            const targetX = startX + (target.index * (letterWidth + refinedSpacing)) + letterWidth / 2;
            const baseY = height * SENTENCE_VERTICAL_POSITION;

            // Start transition
            particle.isFloating = false;
            particle.isDragging = false; // Stop dragging
            particle.isTransitioning = true;
            particle.transitionFrame = 0;
            particle.startX = particle.x;
            particle.startY = particle.y;
            particle.startSize = particle.size;
            particle.startWeight = particle.weight;
            particle.startRotation = particle.rotation;
            particle.targetX = targetX;
            particle.targetY = baseY;
            particle.targetSize = LETTER_CONFIG.placed.size;
            particle.targetWeight = LETTER_CONFIG.placed.weight;
            particle.targetRotation = 0;

            // Ensure font transition completes if it was being dragged
            if (particle.fontFamilyTransition > 0 && particle.fontFamilyTransition < 1) {
                // Continue the font transition during placement
            }

            // Update ALL placed letter colors based on new placement
            // This creates the progressive fade effect
            updateAllPlacedLetterColors();

            // Pronounce the letter
            speakLetter(letter);
        }

        // ========================================
        // WEB SPEECH API
        // ========================================
        function loadVoices() {
            if (!window.speechSynthesis) return;

            // Load voices (may take time on some browsers)
            const loadVoicesAsync = () => {
                availableVoices = speechSynthesis.getVoices();

                if (availableVoices.length > 0) {
                    // Find German male voice
                    germanMaleVoice = availableVoices.find(voice =>
                        voice.lang.startsWith('de') &&
                        (voice.name.toLowerCase().includes('male') ||
                            voice.name.toLowerCase().includes('mann') ||
                            voice.name.toLowerCase().includes('hans') ||
                            voice.name.toLowerCase().includes('markus'))
                    );

                    // Fallback to any German voice
                    if (!germanMaleVoice) {
                        germanMaleVoice = availableVoices.find(voice =>
                            voice.lang.startsWith('de')
                        );
                    }

                    console.log('\n=== AVAILABLE VOICES ===');
                    console.log('German voices:', availableVoices.filter(v => v.lang.startsWith('de')));
                    console.log('Selected German voice:', germanMaleVoice);
                }
            };

            loadVoicesAsync();

            // Voices may load asynchronously
            if (speechSynthesis.onvoiceschanged !== undefined) {
                speechSynthesis.onvoiceschanged = loadVoicesAsync;
            }
        }

        function speakLetter(letter) {
            if (!window.speechSynthesis) return;

            const utterance = new SpeechSynthesisUtterance(letter);
            utterance.lang = 'de-DE'; // German pronunciation for absurdist effect

            // Randomize pitch and rate for chaotic, varied sounds
            utterance.pitch = 0.6 + Math.random() * 1.0; // Range: 0.6 to 1.6
            utterance.rate = 0.7 + Math.random() * 0.8;  // Range: 0.7 to 1.5
            utterance.volume = 0.8 + Math.random() * 0.2; // Range: 0.8 to 1.0

            // Randomly select from available German voices for variety
            if (availableVoices.length > 0) {
                const germanVoices = availableVoices.filter(v => v.lang.startsWith('de'));
                if (germanVoices.length > 0) {
                    const randomVoice = germanVoices[Math.floor(Math.random() * germanVoices.length)];
                    utterance.voice = randomVoice;
                }
            }

            speechSynthesis.cancel(); // Cancel any ongoing speech
            speechSynthesis.speak(utterance);
        }

        function speakFullSentence() {
            if (!window.speechSynthesis) return;

            const utterance = new SpeechSynthesisUtterance(SENTENCE);
            utterance.lang = 'de-DE'; // German pronunciation of French text (absurdist)

            // Mechanical/robotic parameters
            utterance.pitch = 0.8;  // Lower pitch for mechanical tone
            utterance.rate = 0.9;   // Steady, deliberate pace
            utterance.volume = 1.0;

            // Use selected German male voice for cold, mechanical delivery
            if (germanMaleVoice) {
                utterance.voice = germanMaleVoice;
                console.log('Speaking with voice:', germanMaleVoice.name);
            }

            speechSynthesis.cancel();
            speechSynthesis.speak(utterance);
        }

        // ========================================
        // UTILITY FUNCTIONS
        // ========================================
        function lerp(start, end, t) {
            return start + (end - start) * t;
        }

        function easeInOutCubic(t) {
            return t < 0.5
                ? 4 * t * t * t
                : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        function interpolateColorToWhite(hslColor, progress) {
            // Parse HSL color string like "hsl(235, 85%, 52%)"
            const match = hslColor.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
            if (!match) return hslColor;

            const h = parseInt(match[1]);
            const s = parseInt(match[2]);
            const l = parseInt(match[3]);

            // Ease the progress for smoother transition
            const eased = easeInOutCubic(progress);

            // Interpolate to white: hsl(h, 0%, 100%)
            const newS = lerp(s, 0, eased);
            const newL = lerp(l, 100, eased);

            return `hsl(${h}, ${newS}%, ${newL}%)`;
        }

        // ========================================
        // START APPLICATION
        // ========================================
        init();
    </script>
</body>

</html>